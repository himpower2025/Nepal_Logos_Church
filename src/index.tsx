
import React, { useState, useEffect, useRef, useCallback, createContext, useContext, useMemo, memo } from 'react';
import ReactDOM from 'react-dom/client';
import { createPortal } from 'react-dom';
import './index.css';
import { initializeFirebaseServices, FirebaseServices } from './firebase';
import { 
    createUserWithEmailAndPassword, 
    signInWithEmailAndPassword, 
    onAuthStateChanged,
    signOut,
    updateProfile,
    GoogleAuthProvider,
    signInWithPopup,
    User as FirebaseAuthUser,
} from "firebase/auth";
import { 
    collection, 
    addDoc, 
    onSnapshot, 
    query, 
    orderBy, 
    doc, 
    updateDoc, 
    serverTimestamp,
    getDoc,
    setDoc,
    arrayUnion,
    Timestamp,
    where,
    arrayRemove,
    deleteDoc,
    getDocs,
    limit,
    increment
} from "firebase/firestore";
import { ref, getDownloadURL, uploadBytes, deleteObject } from "firebase/storage";
import { getToken, onMessage } from "firebase/messaging";


// --- Firebase Context for safe dependency injection ---
const FirebaseContext = createContext<FirebaseServices | null>(null);
export const useFirebase = () => {
    const context = useContext(FirebaseContext);
    if (!context) {
        throw new Error("useFirebase must be used within a FirebaseProvider");
    }
    return context;
};

// --- Toast Context ---
type ToastMessage = { id: number; title: string; body: string; onClick?: () => void; };
type ToastContextType = {
  showToast: (title: string, body: string, onClick?: () => void) => void;
};
const ToastContext = createContext<ToastContextType | null>(null);
export const useToast = () => {
    const context = useContext(ToastContext);
    if (!context) throw new Error("useToast must be used within a ToastProvider");
    return context;
};

const ToastProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [toasts, setToasts] = useState<ToastMessage[]>([]);
    const toastIdRef = useRef(0);

    const showToast = useCallback((title: string, body: string, onClick?: () => void) => {
        const id = toastIdRef.current++;
        const newToast: ToastMessage = { id, title, body, onClick };
        setToasts(prev => [newToast, ...prev]);

        // Play a notification sound
        try {
            const audio = new Audio('https://firebasestorage.googleapis.com/v0/b/logos-church-nepal.appspot.com/o/assets%2Fnotification.mp3?alt=media&token=24838a14-a901-469b-9a4f-56193796537b'); // Use a publicly accessible sound file
            audio.play().catch(e => console.warn("Audio playback failed:", e));
        } catch(e) {
            console.error("Failed to create or play audio:", e);
        }

        setTimeout(() => {
            setToasts(prev => prev.filter(t => t.id !== id));
        }, 5000);
    }, []);
    
    return (
        <ToastContext.Provider value={{ showToast }}>
            {children}
            <ToastContainer toasts={toasts} />
        </ToastContext.Provider>
    );
};

const ToastContainer: React.FC<{ toasts: ToastMessage[] }> = ({ toasts }) => {
    const [exitingToasts, setExitingToasts] = useState<number[]>([]);

    useEffect(() => {
        const timers: NodeJS.Timeout[] = [];
        toasts.forEach(toast => {
            if (!exitingToasts.includes(toast.id)) {
                const timer = setTimeout(() => {
                    setExitingToasts(prev => [...prev, toast.id]);
                }, 4500); // Start exiting animation before removal
                timers.push(timer);
            }
        });
        return () => timers.forEach(clearTimeout);
    }, [toasts, exitingToasts]);
    
    return createPortal(
        <div className="toast-container">
            {toasts.map(toast => (
                <div 
                    key={toast.id} 
                    className={`toast-item ${exitingToasts.includes(toast.id) ? 'exiting' : ''}`}
                    onClick={toast.onClick}
                >
                    <div className="toast-content">
                        <div className="toast-title">{toast.title}</div>
                        <div className="toast-body">{toast.body}</div>
                    </div>
                </div>
            ))}
        </div>,
        document.body
    );
};


// --- Types ---
type UserRole = 'admin' | 'member' | 'news_contributor' | 'podcast_contributor';
type User = { id: string; name: string; email: string; avatar: string; roles: UserRole[]; fcmTokens?: string[] };
type Church = { id: string; name: string; logo: string; offeringDetails: any; };
type Comment = { id: string; authorId: string; authorName: string; authorAvatar: string; content: string; createdAt: Timestamp; };
type PrayerRequest = { id:string; authorId: string; authorName: string; title: string; content: string; image?: string | null; prayedBy: string[]; comments?: Comment[]; commentCount?: number; createdAt: Timestamp; status?: 'uploading' | 'failed'; tempId?: string; localImagePreview?: string; };
type Podcast = { id: string; title: string; authorId: string; authorName: string; audioUrl: string; createdAt: Timestamp; status?: 'uploading' | 'failed'; tempId?: string; localAudioUrl?: string; };
type NewsItem = { id: string; title: string; content: string; image?: string | null; createdAt: Timestamp; authorId: string, authorName: string; status?: 'uploading' | 'failed'; tempId?: string; localImagePreview?: string; };
type Verse = { verse: string; text: string; };

type MediaItem = {
    url: string;
    type: 'image' | 'video';
    path?: string; // For deletion from storage
};
type Message = {
    id: string;
    senderId: string;
    content?: string;
    media?: MediaItem[];
    createdAt: Timestamp;
    status?: 'uploading' | 'failed';
    tempId?: string;
};

type LastMessage = {
    content: string;
    senderId: string;
    createdAt: Timestamp;
};

type Chat = { 
    id: string; 
    name?: string;
    participantIds: string[]; 
    participants: { [key: string]: { name: string; avatar: string; } }; // Simplified participant info
    lastMessage?: LastMessage;
    lastRead?: { [key: string]: Timestamp };
    lastActivity?: Timestamp;
};

type Notification = {
    id: string;
    icon: string; // material symbol name
    message: string;
    timestamp: string;
};
type WorshipService = {
    id: string;
    isLive: boolean;
    streamUrl: string;
    title: string;
    createdAt: Timestamp;
};

type PastWorshipService = {
    id: string;
    title: string;
    youtubeUrl: string;
    createdAt: Timestamp;
};

// --- Upload-specific type ---
type MediaPreview = {
    url: string;
    file: File;
    type: 'image' | 'video';
    id: string; // Unique ID for tracking progress
};

// --- Static Config & Data ---
const CHURCH: Church = {
    id: 'nepal_logos', name: 'Logos Church, Nepal', logo: '/logos-church-new-logo.jpg',
    offeringDetails: { qrCodeUrl: '/logos-qr-code.png', bankName: 'Global IME Bank', accountHolder: 'YAM PRADHAN', accountNumber: '10507010042662' },
};

const MOCK_VERSES_OF_THE_DAY: Verse[] = [
    { verse: 'यूहन्ना ३:१६', text: 'किनभने परमेश्‍वरले संसारलाई यति साह्रो प्रेम गर्नुभयो, कि उहाँले आफ्‍ना एकमात्र पुत्र दिनुभयो, ताकि उहाँमाथि विश्‍वास गर्ने कोही पनि नाश नहोस्, तर त्‍यसले अनन्त जीवन पाओस्।' },
    { verse: 'फिलिप्पी ४:१३', text: 'जसले मलाई शक्ति दिनuहुन्छ, उहाँमा म सब कुरा गर्न सक्छु।' },
    { verse: 'रोमी ८:२८', text: 'हामी जान्दछौं, कि परमेश्‍वरलाई प्रेम गर्नेहरूका निम्ति, अर्थात् उहाँको अभिप्रायअनुसार बोलाइएकाहरूका निम्ति हरेक कुरामा परमेश्‍वरले भलाइ नै गर्नुहुन्छ।' },
    { verse: 'यशैया ४१:१०', text: 'नडरा, किनभने म तँसँग छु। निरुत्साहित नहो, किनभने म तेरो परमेश्‍वर हुँ। म तँलाई बलियो पार्नेछु, म तँलाई सहायता गर्नेछु, म तँलाई मेरो धार्मिकताको दाहिने हातले समाल्नेछु।' },
    { verse: 'भजनसंग्रह २३:१', text: 'परमप्रभु मेरो गोठालो हुनुहुन्छ, मलाई केही कुराको अभाव हुनेछैन।' },
    { verse: 'यर्मिया २९:११', text: 'किनभने मैले तिमीहरूका निम्ति बनाएका योजनाहरू म जान्दछछु,” परमप्रभु भन्नुहुन्छ, “तिमीहरूलाई हानि गर्ने होइन, तर उन्नति गर्ने योजनाहरू, तिमीहरूलाई आशा र भविष्य दिने योजनाहरू।' },
    { verse: 'मत्ती ११:२८', text: 'हे सबै थाकेका र बोझले दबिएका हो, मकहाँ आओ, र म तिमीहरूलाई विश्राम दिनेछु।' },
    { verse: 'हितोपदेश ३:५-६', text: 'तेरो सारा हृदयले परमप्रभुमाथि भरोसा राख्, र तेरो आफ्नै समझशक्तिमाथि भर नपर्। तेरा सबै मार्गहरूमा उहाँलाई स्वीकार गर्, र उहाँले तेरा मार्गहरू सोझो बनाउनुहुनेछ।' },
    { verse: '२ तिमोथी १:७', text: 'किनभने परमेश्‍वरले हामीलाई डरको आत्मा दिनुभएको छैन, तर शक्ति, प्रेम र आत्मसंयमको आत्मा दिनुभएको छ।' },
    { verse: 'यहोशू १:९', text: 'के मैले तँलाई आज्ञa दिएको छैनँ र? बलियो र साहसी हो। नडरा, न त निरुत्साहित हो, किनभने तँ जहाँ गए पनि परमप्रभु तेरा परमेश्‍वर तँसँग हुनुहुन्छ।' },
    { verse: 'भजनसंग्रह ४६:१', text: 'परमेश्‍वर हाम्रा शरणस्थान र बल हुनुहुन्छ, सङ्कष्टमा तुरुन्तै पाइने सहायक।' },
    { verse: 'मत्ती ६:३३', text: 'तर पहिले उहाँको राज्य र उहाँको धार्मिकताको खोजी गर, र यी सबै कुरा तिमीहरूलाई थपिनेछन्।' },
    { verse: 'गलाती ५:२२-২৩', text: 'तर पवित्र आत्माको फलचाहिँ प्रेम, आनन्द, शान्ति, धैर्य, दया, भलाइ, विश्वस्तता, नम्रता र आत्मसंयम हो।' },
    { verse: 'हिब्रू ११:१', text: 'अब विश्वासचाहिँ आशा राखिएका कुराहरूको निश्चय र नदेखिएका कुराहरूको प्रमाण हो।' },
    { verse: 'रोमी १०:९', text: 'यदि तपाईंले आफ्नो मुखले “येशू नै प्रभु हुनुहुन्छ” भनी स्वीकार गर्नुभयो र परमेश्वरले उहाँलाई मरेकाहरूबाट जीवित पार्नुभयो भनी आफ्नो हृदयमा विश्वास गर्नुभयो भने तपाईंले उद्धार पाउनुहुनेछ।' },
    { verse: 'भजनसंग्रह १:१-२', text: 'धन्य हो त्यो मानिस, जो दुष्टहरूको सल्लाहमा हिँड्दैन, र पापीहरूको मार्गमा खडा हुँदैन, र गिल्ला गर्नेहरूको संगतमा बस्दैन। तर त्यसको खुशी परमप्रभुको व्यवस्थामा रहन्छ, र त्यसले दिनरात उहाँको व्यवस्थामा ध्यान गर्छ।' },
    { verse: 'यशैया ४०:३१', text: 'तर परमप्रभुमा आशा राख्नेहरूले नयाँ शक्ति प्राप्त गर्नेछन्। तिनीहरू गरुडझैं पखेटा लाएर माथि उड्नेछन्। तिनीहरू दगुरेर जानेछन् र थकित हुनेछैनन्, तिनीहरू हिँड्नेछन् र मूर्छित हुनेछैनन्।' },
    { verse: '१ कोरिन्थी १०:१३', text: 'तिमीहरूमाथि आइपरेको कुनै पनि परीक्षा मानिसलाई साधारणतया आइपर्नेभन्दा बाहिरको छैन। र परमेश्वर विश्वासयोग्य हुनुहुन्छ। उहाँले तिमीहरूलाई तिमीहरूको शक्तिभन्दा बाहिरको परीक्षामा पर्न दिनुहुनेछैन।' },
    { verse: 'एफिसी २:८-९', text: 'किनभने अनुग्रहबाट विश्वासद्वारा तिमीहरूले उद्धार पाएका छौ—र यो तिमीहरू आफैबाट होइन, यो परमेश्वरको वरदान हो—कर्महरूद्वारा होइन, ताकि कसैले घमण्ड गर्न नपाओस्।' },
    { verse: 'भजनसंग्रह ३७:४', text: 'परमप्रभुमा आनन्दित हो, र उहाँले तेरो हृदयका इच्छाहरू पूरा गर्नुहुनेछ।' },
    { verse: '२ कोरिन्थी ५:१७', text: 'यसकारण, यदि कोही ख्रीष्टमा छ भने, ऊ नयाँ सृष्टि हो। पुरानो बितिगएको छ, हेर, नयाँ आएको छ!' },
    { verse: 'हितोपदेश २२:६', text: 'बालकलाई त्यसको हिँड्नुपर्ने बाटोमा तालिम दे, र ऊ बूढो हुँदा पनि त्यसबाट तर्कनेछैन।' },
    { verse: 'भजनसंग्रह ११९:१०५', text: 'तपाईंको वचन मेरो खुट्टाको निम्ति बत्ती, र मेरो बाटोको निम्ति उज्यालो हो।' }
];

const MCCHEYNE_READING_PLAN = [
    "उत्पत्ति १, मत्ती १, एज्रा १, प्रेरित १",
    "उत्पत्ति २, मत्ती २, एज्रा २, प्रेरित २",
    "उत्पत्ति ३, मत्ती ३, एज्रा ३, प्रेरित ३",
    "उत्पत्ति ४, मत्ती ४, एज्रा ४, प्रेरित ४",
    "उत्पत्ति ५, मत्ती ५, एज्रा ५, प्रेरित ५",
    "उत्पत्ति ६, मत्ती ६, एज्रा ६, प्रेरित ६",
    "उत्पत्ति ७, मत्ती ७, एज्रा ७, प्रेरित ७",
    "उत्पत्ति ८, मत्ती ८, एज्रा ८, प्रेरित ८",
    "उत्पत्ति ९, मत्ती ९, एज्रा ९, प्रेरित ९",
    "उत्पत्ति १०, मत्ती १०, एज्रा १०, प्रेरित १०",
    "उत्पत्ति ११, मत्ती ११, नहेम्याह १, प्रेरित ११",
    "उत्पत्ति १२, मत्ती १२, नहेम्याह २, प्रेरित १२",
    "उत्पत्ति १३, मत्ती १३, नहेम्याह ३, प्रेरित १३",
    "उत्पत्ति १४, मत्ती १४, नहेम्याह ४, प्रेरित १४",
    "उत्पत्ति १५, मत्ती १५, नहेम्याह ५, प्रेरित १५",
    "उत्पत्ति १६, मत्ती १६, नहेम्याह ६, प्रेरित १६",
    "उत्पत्ति १७, मत्ती १७, नहेम्याह ७, प्रेरित १७",
    "उत्पत्ति १८, मत्ती १८, नहेम्याह ८, प्रेरित १८",
    "उत्पत्ति १९, मत्ती १९, नहेम्याह ९, प्रेरित १९",
    "उत्पत्ति २०, मत्ती २०, नहेम्याह १०, प्रेरित २०",
    "उत्पत्ति २१, मत्ती २१, नहेम्याह ११, प्रेरित २१",
    "उत्पत्ति २२, मत्ती २२, नहेम्याह १२, प्रेरित २२",
    "उत्पत्ति ২৩, मत्ती ২৩, नहेम्याह १३, प्रेरित ২৩",
    "उत्पत्ति २४, मत्ती २४, एस्तर १, प्रेरित २४",
    "उत्पत्ति २५, मत्ती २५, एस्तर २, प्रेरित २५",
    "उत्पत्ति २६, मत्ती २６, एस्तर ३, प्रेरित २६",
    "उत्पत्ति २७, मत्ती २७, एस्तर ४, प्रेरित २७",
    "उत्पत्ति २८, मत्ती २८, एस्तर ५, प्रेरित २८",
    "उत्पत्ति २९, मर्कूस १, एस्तर ६, रोमी १",
    "उत्पत्ति ३०, मर्कूस २, एस्तर ७, रोमी २",
    "उत्पत्ति ३१, मर्कूस ३, एस्तर ८, रोमी ३",
    "उत्पत्ति ३２, मर्कूस ४, एस्तर ९, रोमी ४",
    "उत्पत्ति ३३, मर्कूस ५, एस्तर १०, रोमी ५",
    "उत्पत्ति ३४, मर्कूस ६, अय्यूब १, रोमी ६",
    "उत्पत्ति ३५, मर्कूस ७, अय्यूब २, रोमी ७",
    "उत्पत्ति ३６, मर्कूस ८, अय्यूब ३, रोमी ८",
    "उत्पत्ति ३७, मर्कूस ९, अय्यूब ४, रोमी ९",
    "उत्पत्ति ३८, मर्कूस १०, अय्यूब ५, रोमी १०",
    "उत्पत्ति ३９, मर्कूस ११, अय्यूब ६, रोमी ११",
    "उत्पत्ति ४०, मर्कूस १२, अय्यूब ७, रोमी १२",
    "उत्पत्ति ४१, मर्कूस १३, अय्यूब ८, रोमी १३",
    "उत्पत्ति ४２, मर्कूस १४, अय्यूब ९, रोमी १४",
    "उत्पत्ति ४३, मर्कूस १५, अय्यूब १०, रोमी १५",
    "उत्पत्ति ４４, मर्कूस १६, अय्यूब ११, रोमी १६",
    "उत्पत्ति ४५, लूका १:१-३८, अय्यूब १२, १ कोरिन्थी १",
    "उत्पत्ति ४६, लूका १:३९-८०, अय्यूब १३, १ कोरिन्थी २",
    "उत्पत्ति ४７, लूका २:१-२४, अय्यूब १४, १ कोरिन्थी ३",
    "उत्पत्ति ४८, लूका २:२५-５２, अय्यूब १५, १ कोरिन्थी ४",
    "उत्पत्ति ४९, लूका ३, अय्यूब १६, १ कोरिन्थी ५",
    "उत्पत्ति ५०, लूका ४:१-३０, अय्यूब १७, १ कोरिन्थी ६",
    "प्रस्थान १, लूका ४:३१-४४, अय्यूब १८, १ कोरिन्थी ७",
    "प्रस्थान २, लूका ५:१-१६, अय्यूब १९, १ कोरिन्थी ८",
    "प्रस्थान ३, लूका ५:१७-३９, अय्यूब २०, १ कोरिन्थी ९",
    "प्रस्थान ४, लूका ६:१-१९, अय्यूब २१, १ कोरिन्थी १०",
    "प्रस्थान ५, लूका ६:२०-４９, अय्यूब २２, १ कोरिन्थी ११",
    "प्रस्थान ६, लूका ७:१-२३, अय्यूब ২৩, १ कोरिन्थी १२",
    "प्रस्थान ७, लूका ७:२४-५०, अय्यूब २४, १ कोरिन्थी १३",
    "प्रस्थान ८, लूका ८:१-२५, अय्यूब २५, १ कोरिन्थी १४",
    "प्रस्थान ९, लूका ८:२６-５６, अय्यूब २६, १ कोरिन्थी १५",
    "प्रस्थान १०, लूका ९:१-१८, अय्यूब २७, १ कोरिन्थी १६",
    "प्रस्थान ११, लूका ९:१९-३６, अय्यूब २८, २ कोरिन्थी १",
    "प्रस्थान १२, लूका ९:३७-６２, अय्यूब २९, २ कोरिन्थी २",
    "प्रस्थान १३, लूका १०:१-२４, अय्यूब ३०, २ कोरिन्थी ३",
    "प्रस्थान १४, लूका १०:२५-４２, अय्यूब ३１, २ कोरिन्थी ४",
    "प्रस्थान १५, लूका ११:१-२८, अय्यूब ३２, २ कोरिन्थी ५",
    "प्रस्थान १६, लूका ११:२९-５４, अय्यूब ३３, २ कोरिन्थी ६",
    "प्रस्थान १७, लूका १२:१-३４, अय्यूब ३४, २ कोरिन्थी ७",
    "प्रस्थान १८, लूका १२:३५-५९, अय्यूब ३５, २ कोरिन्थी ८",
    "प्रस्थान १९, लूका १३, अय्यूब ३６, २ कोरिन्थी ९",
    "प्रस्थान २०, लूका १४:१-२４, अय्यूब ३７, २ कोरिन्थी १०",
    "प्रस्थान २१, लूका १४:२५-३५, अय्यूब ३８, २ कोरिन्थी ११",
    "प्रस्थान २２, लूका १५, अय्यूब ३９, २ कोरिन्थी १२",
    "प्रस्थान ২৩, लूका १६, अय्यूब ४०, २ कोरिन्थी १३",
    "प्रस्थान २४, लूका १७:१-१९, अय्यूब ४१, गलाती १",
    "प्रस्थान २५, लूका १७:२०-३７, अय्यूब ४２, गलाती २",
    "प्रस्थान २६, लूका १८:१-१८, भजनसंग्रह १-२, गलाती ३",
    "प्रस्थान २७, लूका १८:१९-４３, भजनसंग्रह ३-४, गलाती ४",
    "प्रस्थान २८, लूका १९:१-२७, भजनसंग्रह ५-६, गलाती ५",
    "प्रस्थान २९, लूका १९:२८-４８, भजनसंग्रह ७, गलाती ६",
    "प्रस्थान ३०, लूका २०:१-१९, भजनसंग्रह ८, एफिसी १",
    "प्रस्थान ३１, लूका २०:२०-４७, भजनसंग्रह ९, एफिसी २",
    "प्रस्थान ३２, लूका २१, भजनसंग्रह १०, एफिसी ३",
    "प्रस्थान ३३, लूका २２:१-३０, भजनसंग्रह ११-१२, एफिसी ४",
    "प्रस्थान ३４, लूका २２:३१-५३, भजनसंग्रह १३-१४, एफिसी ५",
    "प्रस्थान ३५, लूका २２:５४-७१, भजनसंग्रह १५-१６, एफिसी ६",
    "प्रस्थान ३６, लूका ২৩:१-२५, भजनसंग्रह १७, फिलिप्पी १",
    "प्रस्थान ३७, लूका २३:२६-５６, भजनसंग्रह १८, फिलिप्पी २",
    "प्रस्थान ३８, लूका २४:१-१२, भजनसंग्रह १९, फिलिप्पी ३",
    "प्रस्थान ३９, लूका २४:१३-５३, भजनसंग्रह २०, फिलिप्पी ४",
    "प्रस्थान ४०, यूहन्ना १:१-२८, भजनसंग्रह २१, कलस्सी १",
    "लेवी १, यूहन्ना १:२९-５１, भजनसंग्रह २२, कलस्सी २",
    "लेवी २, यूहन्ना २, भजनसंग्रह ২৩, कलस्सी ३",
    "लेवी ३, यूहन्ना ३:१-२１, भजनसंग्रह २४, कलस्सी ४",
    "लेवी ४, यूहन्ना ३:२२-३６, भजनसंग्रह २५, १ थिस्सलोनिकी १",
    "लेवी ५, यूहन्ना ४:१-३０, भजनसंग्रह २६, १ थिस्सलोनिकी २",
    "लेवी ६, यूहन्ना ४:३१-５４, भजनसंग्रह २७, १ थिस्सलोनिकी ३",
    "लेवी ७, यूहन्ना ५:१-२३, भजनसंग्रह २८, १ थिस्सलोनिकी ४",
    "लेवी ८, यूहन्ना ५:２４-４７, भजनसंग्रह २९, १ थिस्सलोनिकी ५",
    "लेवी ९, यूहन्ना ६:१-२１, भजनसंग्रह ३０, २ थिस्सलोनिकी १",
    "लेवी १०, यूहन्ना ६:२２-４０, भजनसंग्रह ३１, २ थिस्सलोनिकी २",
    "लेवी ११, यूहन्ना ६:४१-७１, भजनसंग्रह ३２, २ थिस्सलोनिकी ३",
    "लेवी १२, यूहन्ना ७:१-३１, भजनसंग्रह ३३, १ तिमोथी १",
    "लेवी १३, यूहन्ना ७:३２-５३, भजनसंग्रह ३４, १ तिमोथी २",
    "लेवी १४, यूहन्ना ८:१-३０, भजनसंग्रह ३५, १ तिमोथी ३",
    "लेवी १५, यूहन्ना ८:३१-५९, भजनसंग्रह ३６, १ तिमोथी ४",
    "लेवी १६, यूहन्ना ९, भजनसंग्रह ३７, १ तिमोथी ५",
    "लेवी १७, यूहन्ना १०:१-२１, भजनसंग्रह ३８, १ तिमोथी ६",
    "लेवी १८, यूहन्ना १०:२२-４２, भजनसंग्रह ३９, २ तिमोथी १",
    "लेवी १९, यूहन्ना ११:१-२７, भजनसंग्रह ४०, २ तिमोथी २",
    "लेवी २०, यूहन्ना ११:२８-５７, भजनसंग्रह ४१, २ तिमोथी ३",
    "लेवी २१, यूहन्ना १२:१-१९, भजनसंग्रह ४２, २ तिमोथी ४",
    "लेवी २２, यूहन्ना १२:२०-５０, भजनसंग्रह ४३, तीतस १",
    "लेवी ২৩, यूहन्ना १३, भजनसंग्रह ۴４, तीतस २",
    "लेवी २४, यूहन्ना १४, भजनसंग्रह ४５, तीतस ३",
    "लेवी २५, यूहन्ना १५, भजनसंग्रह ४６, फिलेमोन १",
    "लेवी २６, यूहन्ना १६, भजनसंग्रह ४７, हिब्रू १",
    "लेवी २७, यूहन्ना १७, भजनसंग्रह ४８, हिब्रू २",
    "गन्ती १, यूहन्ना १८:१-२३, भजनसंग्रह ۴९, हिब्रू ३",
    "गन्ती २, यूहन्ना १८:２４-４０, भजनसंग्रह ५０, हिब्रू ४",
    "गन्ती ३, यूहन्ना १९:१-२２, भजनसंग्रह ५१, हिब्रू ५",
    "गन्ती ४, यूहन्ना १९:२３-４２, भजनसंग्रह ५２, हिब्रू ६",
    "गन्ती ५, यूहन्ना २०, भजनसंग्रह ५३, हिब्रू ७",
    "गन्ती ६, यूहन्ना २１, भजनसंग्रह ५４, हिब्रू ८",
    "गन्ती ७, प्रेरित १, भजनसंग्रह ५５, हिब्रू ९",
    "गन्ती ८, प्रेरित २:१-२१, भजनसंग्रह ५６, हिब्रू १०",
    "गन्ती ९, प्रेरित २:२２-４７, भजनसंग्रह ५७, हिब्रू ११",
    "गन्ती १०, प्रेरित ३, भजनसंग्रह ५८, हिब्रू १२",
    "गन्ती ११, प्रेरित ४:१-२２, भजनसंग्रह ५९, हिब्रू १३",
    "गन्ती १२, प्रेरित ४:२३-３７, भजनसंग्रह ६０, याकूब १",
    "गन्ती १३, प्रेरित ५:१-१८, भजनसंग्रह ६１, याकूब २",
    "गन्ती १४, प्रेरित ५:१९-４２, भजनसंग्रह ६２, याकूब ३",
    "गन्ती १५, प्रेरित ६, भजनसंग्रह ६３, याकूब ४",
    "गन्ती १६, प्रेरित ७:१-२१, भजनसंग्रह ६４, याकוב ५",
    "गन्ती १७, प्रेरित ७:२２-४३, भजनसंग्रह ६５, १ पत्रुस १",
    "गन्ती १८, प्रेरित ७:४４-６०, भजनसंग्रह ६６, १ पत्रुस २",
    "गन्ती १९, प्रेरित ८:१-२५, भजनसंग्रह ६७, १ पत्रुस ३",
    "गन्ती २०, प्रेरित ८:２６-４０, भजनसंग्रह ६८, १ पत्रुस ४",
    "गन्ती २१, प्रेरित ९:१-२１, भजनसंग्रह ६९, १ पत्रुस ५",
    "गन्ती २２, प्रेरित ९:२२-４३, भजनसंग्रह ७０, २ पत्रुस १",
    "गन्ती ২৩, प्रेरित १०:१-२३, भजनसंग्रह ७１, २ पत्रुस २",
    "गन्ती २४, प्रेरित १०:२４-４８, भजनसंग्रह ७２, २ पत्रुस ३",
    "गन्ती २५, प्रेरित ११, भजनसंग्रह ७３, १ यूहन्ना १",
    "गन्ती २６, प्रेरित १२, भजनसंग्रह ७４, १ यूहन्ना २",
    "गन्ती २७, प्रेरित १३:१-२５, भजनसंग्रह ७５, १ यूहन्ना ३",
    "गन्ती २८, प्रेरित १३:２６-５２, भजनसंग्रह ७６, १ यूहन्ना ४",
    "गन्ती २९, प्रेरित १४, भजनसंग्रह ७７, १ यूहन्ना ५",
    "गन्ती ३０, प्रेरित १५:१-२१, हितोपदेश १, २ यूहन्ना १",
    "गन्ती ३１, प्रेरित १५:२२-４१, हितोपदेश २, ३ यूहन्ना १",
    "गन्ती ३２, प्रेरित १६, हितोपदेश ३, यहूदा १",
    "गन्ती ३३, प्रेरित १७:१-१５, हितोपदेश ४, प्रकाश १",
    "गन्ती ३４, प्रेरित १७:१६-３４, हितोपदेश ५, प्रकाश २",
    "गन्ती ३５, प्रेरित १८, हितोपदेश ६, प्रकाश ३",
    "गन्ती ३６, प्रेरित १९, हितोपदेश ७, प्रकाश ४",
    "व्यवस्था १, प्रेरित २०:१-१６, हितोपदेश ८, प्रकाश ५",
    "व्यवस्था २, प्रेरित २०:१７-३८, हितोपदेश ९, प्रकाश ६",
    "व्यवस्था ३, प्रेरित २१:१-१८, उपदेशक १, प्रकाश ७",
    "व्यवस्था ४, प्रेरित २१:१९-４３, उपदेशक २, प्रकाश ८",
    "व्यवस्था ५, प्रेरित २２, उपदेशक ३, प्रकाश ९",
    "व्यवस्था ६, प्रेरित ২৩, उपदेशक ४, प्रकाश १०",
    "व्यवस्था ७, प्रेरित २४, उपदेशक ५, प्रकाश ११",
    "व्यवस्था ८, प्रेरित २५, उपदेशक ६, प्रकाश १२",
    "व्यवस्था ९, प्रेरित २６, उपदेशक ७, प्रकाश १३",
    "व्यवस्था १०, प्रेरित २７, उपदेशक ८, प्रकाश १४",
    "व्यवस्था ११, प्रेरित २８, उपदेशक ९, प्रकाश १५",
    "व्यवस्था १२, रोमी १, उपदेशक १०, प्रकाश १६",
    "व्यवस्था १३, रोमी २, उपदेशक ११, प्रकाश १७",
    "व्यवस्था १४, रोमी ३, उपदेशक १२, प्रकाश १८",
    "व्यवस्था १५, रोमी ४, श्रेष्ठगीत १, प्रकाश १९",
    "व्यवस्था १६, रोमी ५, श्रेष्ठगीत २, प्रकाश २०",
    "व्यवस्था १७, रोमी ६, श्रेष्ठगीत ३, प्रकाश २१",
    "व्यवस्था १८, रोमी ७, श्रेष्ठगीत ४, प्रकाश २２",
    "व्यवस्था १९, रोमी ८:१-१८, श्रेष्ठगीत ५, यशैया १",
    "व्यवस्था २०, रोमी ८:१९-३९, श्रेष्ठगीत ६, यशैया २",
    "व्यवस्था २१, रोमी ९, श्रेष्ठगीत ७, यशैया ३",
    "व्यवस्था २２, रोमी १०, श्रेष्ठगीत ८, यशैया ४",
    "व्यवस्था ২৩, रोमी ११:१-२４, यशैया १, यशैया ५",
    "व्यवस्था २४, रोमी ११:２５-３６, यशैया २, यशैया ६",
    "व्यवस्था २५, रोमी १२, यशैया ३, यशैया ७",
    "व्यवस्था २６, रोमी १३, यशैया ४, यशैया ८",
    "व्यवस्था २७, रोमी १४, यशैया ५, यशैया ९",
    "व्यवस्था २८, रोमी १५:१-१८, यशैया ६, यशैया १०",
    "व्यवस्था २९, रोमी १५:१९-３３, यशैया ७, यशैया ११",
    "व्यवस्था ३０, रोमी १६, यशैया ८, यशैया १२",
    "व्यवस्था ३１, १ कोरिन्थी १, यशैया ९, यशैया १३",
    "व्यवस्था ३２, १ कोरिन्थी २, यशैया १०, यशैया १४",
    "व्यवस्था ३３, १ कोरिन्थी ३, यशैया ११, यशैया १५",
    "व्यवस्था ३４, १ कोरिन्थी ४, यशैया १२, यशैया १६",
    "यहोशू १, १ कोरिन्थी ५, यशैया १३, यशैया १७",
    "यहोशू २, १ कोरिन्थी ६, यशैया १४, यशैया १८",
    "यहोशू ३, १ कोरिन्थी ७, यशैया १५, यशैया १९",
    "यहोशू ४, १ कोरिन्थी ८, यशैया १६, यशैया २०",
    "यहोशू ५, १ कोरिन्थी ९, यशैया १७, यशैया २१",
    "यहोशू ६, १ कोरिन्थी १०, यशैया १८, यशैया २２",
    "यहोशू ७, १ कोरिन्थी ११, यशैया १९, यशैया ২৩",
    "यहोशू ८, १ कोरिन्थी १२, यशैया २०, यशैया २४",
    "यहोशू ९, १ कोरिन्थी १३, यशैया २१, यशैया २५",
    "यहोशू १०, १ कोरिन्थी १४, यशैया २２, यशैया २६",
    "यहोशू ११, १ कोरिन्थी १५, यशैया ২৩, यशैया २７",
    "यहोशू १२, १ कोरिन्थी १६, यशैया २४, यशैया २८",
    "यहोशू १३, २ कोरिन्थी १, यशैया २५, यशैया २९",
    "यहोशू १४, २ कोरिन्थी २, यशैया २६, यशैया ३０",
    "यहोशू १५, २ कोरिन्थी ३, यशैया २७, यशैया ३１",
    "यहोशू १६, २ कोरिन्थी ४, यशैया २८, यशैया ३２",
    "यहोशू १७, २ कोरिन्थी ५, यशैया २९, यशैया ३３",
    "यहोशू १८, २ कोरिन्थी ६, यशैया ३０, यशैया ३４",
    "यहोशू १९, २ कोरिन्थी ७, यशैया ३１, यशैया ३５",
    "यहोशू २०, २ कोरिन्थी ८, यशैया ३２, यशैया ३６",
    "यहोशू २१, २ कोरिन्थी ९, यशैया ३３, यशैया ३７",
    "यहोशू २２, २ कोरिन्थी १०, यशैया ३４, यशैया ३８",
    "यहोशू ২৩, २ कोरिन्थी ११, यशैया ३５, यशैया ३９",
    "यहोशू २४, २ कोरिन्थी १२, यशैया ३６, यशैया ४０",
    "न्यायकर्ता १, २ कोरिन्थी १३, यशैया ३７, यशैया ४１",
    "न्यायकर्ता २, गलाती १, यशैया ३８, यशैया ४２",
    "न्यायकर्ता ३, गलाती २, यशैया ३९, यशैया ४３",
    "न्यायकर्ता ४, गलाती ३, यशैया ४０, यशैया ४４",
    "न्यायकर्ता ५, गलाती ४, यर्मिया १, यशैया ४５",
    "न्यायकर्ता ६, गलाती ५, यर्मिया २, यशैया ४６",
    "न्यायकर्ता ७, गलाती ६, यर्मिया ३, यशैया ४７",
    "न्यायकर्ता ८, एफिसी १, यर्मिया ४, यशैया ४८",
    "न्यायकर्ता ९, एफिसी २, यर्मिया ५, यशैया ४９",
    "न्यायकर्ता १०, एफिसी ३, यर्मिया ६, यशैया ५０",
    "न्यायकर्ता ११, एफिसी ४, यर्मिया ७, यशैया ५１",
    "न्यायकर्ता १२, एफिसी ५, यर्मिया ८, यशैया ५２",
    "न्यायकर्ता १३, एफिसी ६, यर्मिया ९, यशैया ५３",
    "न्यायकर्ता १४, फिलिप्पी १, यर्मिया १०, यशैया ५４",
    "न्यायकर्ता १५, फिलिप्पी २, यर्मिया ११, यशैया ५५",
    "न्यायकर्ता १६, फिलिप्पी ३, यर्मिया १२, यशैया ५６",
    "न्यायकर्ता १७, फिलिप्पी ४, यर्मिया १३, यशैया ५７",
    "न्यायकर्ता १८, कलस्सी १, यर्मिया १४, यशैया ५８",
    "न्यायकर्ता १९, कलस्सी २, यर्मिया १५, यशैया ५९",
    "न्यायकर्ता २०, कलस्सी ३, यर्मिया १६, यशैया ६０",
    "न्यायकर्ता २१, कलस्सी ४, यर्मिया १७, यशैया ६１",
    "रूथ १, १ थिस्सलोनिकी १, यर्मिया १८, यशैया ६２",
    "रूथ २, १ थिस्सलोनिकी २, यर्मिया १९, यशैया ६３",
    "रूथ ३, १ थिस्सलोनिकी ३, यर्मिया २०, यशैया ६４",
    "रूथ ४, १ थिस्सलोनिकी ४, यर्मिया २१, यशैया ६５",
    "१ शमूएल १, १ थिस्सलोनिकी ५, यर्मिया २２, यशैया ६６",
    "१ शमूएल २, २ थिस्सलोनिकी १, यर्मिया ২৩, विलाप १",
    "१ शमूएल ३, २ थिस्सलोनिकी २, यर्मिया २४, विलाप २",
    "१ शमूएल ४, २ थिस्सलोनिकी ३, यर्मिया २५, विलाप ३",
    "१ शमूएल ५, १ तिमोथी १, यर्मिया २६, विलाप ४",
    "१ शमूएल ६, १ तिमोथी २, यर्मिया २७, विलाप ५",
    "१ शमूएल ७, १ तिमोथी ३, यर्मिया २８, इजकिएल १",
    "१ शमूएल ८, १ तिमोथी ४, यर्मिया २९, इजकिएल २",
    "१ शमूएल ९, १ तिमोथी ५, यर्मिया ३०, इजकिएल ३",
    "१ शमूएल १०, १ तिमोथी ६, यर्मिया ३１, इजकिएल ४",
    "१ शमूएल ११, २ तिमोथी १, यर्मिया ३２, इजकिएल ५",
    "१ शमूएल १२, २ तिमोथी २, यर्मिया ३３, इजकिएल ६",
    "१ शमूएल १३, २ तिमोथी ३, यर्मिया ३４, इजकिएल ७",
    "१ शमूएल १४, २ तिमोथी ४, यर्मिया ३５, इजकिएल ८",
    "१ शमूएल १५, तीतस १, यर्मिया ३６, इजकिएल ९",
    "१ शमूएल १६, तीतस २, यर्मिया ३７, इजकिएल १०",
    "१ शमूएल १७, तीतस ३, यर्मिया ३８, इजकिएल ११",
    "१ शमूएल १८, फिलेमोन १, यर्मिया ३９, इजकिएल १२",
    "१ शमूएल १९, हिब्रू १, यर्मिया ४०, इजकिएल १३",
    "१ शमूएल २०, हिब्रू २, यर्मिया ४१, इजकिएल १४",
    "१ शमूएल २१, हिब्रू ३, यर्मिया ४２, इजकिएल १५",
    "१ शमूएल २２, हिब्रू ४, यर्मिया ४３, इजकिएल १६",
    "१ शमूएल ২৩, हिब्रू ५, यर्मिया ४４, इजकिएल १७",
    "१ शमूएल २४, हिब्रू ६, यर्मिया ४５, इजकिएल १८",
    "१ शमूएल २५, हिब्रू ७, यर्मिया ४６, इजकिएल १९",
    "१ शमूएल २६, हिब्रू ८, यर्मिया ४７, इजकिएल २०",
    "१ शमूएल २７, हिब्रू ९, यर्मिया ४８, इजकिएल २१",
    "१ शमूएल २८, हिब्रू १०, यर्मिया ४９, इजकिएल २２",
    "१ शमूएल २९, हिब्रू ११, यर्मिया ५０, इजकिएल ২৩",
    "१ शमूएल ३０, हिब्रू १२, यर्मिया ५１, इजकिएल २४",
    "१ शमूएल ३１, हिब्रू १३, यर्मिया ५２, इजकिएल २५",
    "२ शमूएल १, याकूब १, दानिएल १, इजकिएल २６",
    "२ शमूएल २, याकוב २, दानिएल २, इजकिएल २７",
    "२ शमूएल ३, याकूब ३, दानिएल ३, इजकिएल २८",
    "२ शमूएल ४, याकूब ४, दानिएल ४, इजकिएल २९",
    "२ शमूएल ५, याकूब ५, दानिएल ५, इजकिएल ३０",
    "२ शमूएल ६, १ पत्रुस १, दानिएल ६, इजकिएल ३１",
    "२ शमूएल ७, १ पत्रुस २, दानिएल ७, इजकिएल ३２",
    "२ शमूएल ८, १ पत्रुस ३, दानिएल ८, इजकिएल ३３",
    "२ शमूएल ९, १ पत्रुस ४, दानिएल ९, इजकिएल ३４",
    "२ शमूएल १०, १ पत्रुस ५, दानिएल १०, इजकिएल ३５",
    "२ शमूएल ११, २ पत्रुस १, दानिएल ११, इजकिएल ३６",
    "२ शमूएल १२, २ पत्रुस २, दानिएल १२, इजकिएल ३７",
    "२ शमूएल १३, २ पत्रुस ३, होशे १, इजकिएल ३８",
    "२ शमूएल १४, १ यूहन्ना १, होशे २, इजकिएल ३９",
    "२ शमूएल १५, १ यूहन्ना २, होशे ३, इजकिएल ४०",
    "२ शमूएल १६, १ यूहन्ना ३, होशे ४, इजकिएल ४１",
    "२ शमूएल १७, १ यूहन्ना ४, होशे ५, इजकिएल ४２",
    "२ शमूएल १८, १ यूहन्ना ५, होशे ६, इजकिएल ४３",
    "२ शमूएल १९, २ यूहन्ना १, होशे ७, इजकिएल ४４",
    "२ शमूएल २०, ३ यूहन्ना १, होशे ८, इजकिएल ४５",
    "२ शमूएल २१, यहूदा १, होशे ९, इजकिएल ४６",
    "२ शमूएल २２, प्रकाश १, होशे १०, इजकिएल ४７",
    "२ शमूएल ২৩, प्रकाश २, होशे ११, इजकिएल ४８",
    "२ शमूएल २४, प्रकाश ३, होशे १२, योएल १",
    "१ राजा १, प्रकाश ४, होशे १३, योएल २",
    "१ राजा २, प्रकाश ५, होशे १४, योएल ३",
    "१ राजा ३, प्रकाश ६, आमोस १, आमोस २",
    "१ राजा ४, प्रकाश ७, आमोस ३, आमोस ४",
    "१ राजा ५, प्रकाश ८, आमोस ५, आमोस ६",
    "१ राजा ६, प्रकाश ९, आमोस ७, आमोस ८",
    "१ राजा ७, प्रकाश १०, आमोस ९, ओबद्या १",
    "१ राजा ८, प्रकाश ११, योना १, योना २",
    "१ राजा ९, प्रकाश १२, योना ३, योना ४",
    "१ राजा १०, प्रकाश १३, मीका १, मीका २",
    "१ राजा ११, प्रकाश १४, मीका ३, मीका ४",
    "१ राजा १२, प्रकाश १५, मीका ५, मीका ६",
    "१ राजा १३, प्रकाश १६, मीका ७, नहूम १",
    "१ राजा १४, प्रकाश १७, नहूम २, नहूम ३",
    "१ राजा १५, प्रकाश १८, हबकूक १, हबकूक २",
    "१ राजा १६, प्रकाश १९, हबकूक ३, सपन्याह १",
    "१ राजा १७, प्रकाश २०, सपन्याह २, सपन्याह ३",
    "१ राजा १८, प्रकाश २१, हाग्गै १, हाग्गै २",
    "१ राजा १९, प्रकाश २２, जकरिया १, जकरिया २",
    "१ राजा २०, मत्ती १, जकरिया ३, जकरिया ४",
    "१ राजा २१, मत्ती २, जकरिया ५, जकरिया ६",
    "१ राजा २２, मत्ती ३, जकरिया ७, जकरिया ८",
    "२ राजा १, मत्ती ४, जकरिया ९, जकरिया १०",
    "२ राजा २, मत्ती ५, जकरिया ११, जकरिया १२",
    "२ राजा ३, मत्ती ६, जकरिया १३, जकरिया १४",
    "२ राजा ४, मत्ती ७, मलाकी १, मलाकी २",
    "२ राजा ५, मत्ती ८, मलाकी ३, मलाकी ४",
    "२ राजा ६, मत्ती ९, भजनसंग्रह १-२, भजनसंग्रह ३",
    "२ राजा ७, मत्ती १०, भजनसंग्रह ४-५, भजनसंग्रह ६",
    "२ राजा ८, मत्ती ११, भजनसंग्रह ७, भजनसंग्रह ८",
    "२ राजा ९, मत्ती १२, भजनसंग्रh ९, भजनसंग्रह १०",
    "२ राजा १०, मत्ती १३, भजनसंग्रह ११-१२, भजनसंग्रह १३",
    "२ राजा ११, मत्ती १४, भजनसंग्रh १४, भजनसंग्रh १५",
    "२ राजा १२, मत्ती १५, भजनसंग्रh १६, भजनसंग्रh १७",
    "२ राजा १३, मत्ती १६, भजनसंग्रh १८, भजनसंग्रh १९",
    "२ राजा १४, मत्ती १७, भजनसंग्रh २०, भजनसंग्रh २१",
    "२ राजा १५, मत्ती १८, भजनसंग्रh २２, भजनसंग्रh ২৩",
    "२ राजा १६, मत्ती १९, भजनसंग्रh २४, भजनसंग्रh २५",
    "२ राजा १७, मत्ती २०, भजनसंग्रh २６, भजनसंग्रh २７",
    "२ राजा १८, मत्ती २１, भजनसंग्रh २８, भजनसंग्रh २९",
    "२ राजा १९, मत्ती २２, भजनसंग्रh ३०, भजनसंग्रh ३１",
    "२ राजा २०, मत्ती ২৩, भजनसंग्रh ३２, भजनसंग्रh ३३",
    "२ राजा २१, मत्ती २४, भजनसंग्रh ३４, भजनसंग्रh ३５",
    "२ राजा २２, मत्ती २५, भजनसंग्रh ३６, भजनसंग्रh ३７",
    "२ राजा ২৩, मत्ती २６, भजनसंग्रh ३८, भजनसंग्रh ३９",
    "२ राजा २४, मत्ती २７, भजनसंग्रh ४०, भजनसंग्रh ४१",
    "२ राजा २५, मत्ती २８, भजनसंग्रh ४２, भजनसंग्रh ४३",
    "१ इतिहास १, मर्कूस १, भजनसंग्रh ४４, भजनसंग्रh ४५",
    "१ इतिहास २, मर्कूस २, भजनसंग्रh ৪६, भजनसंग्रh ४७",
    "१ इतिहास ३, मर्कूस ३, भजनसंग्रh ४८, भजनसंग्रh ४९",
    "१ इतिहास ४, मर्कूस ४, भजनसंग्रh ५０, भजनसंग्रh ५１",
    "१ इतिहास ५, मर्कूस ५, भजनसंग्रh ५２, भजनसंग्रh ५३",
    "१ इतिहास ६, मर्कूस ६, भजनसंग्रh ५４, भजनसंग्रh ५５",
    "१ इतिहास ७, मर्कूस ७, भजनसंग्रh ५６, भजनसंग्रh ५७",
    "१ इतिहास ८, मर्कूस ८, भजनसंग्रh ५८, भजनसंग्रh ५९",
    "१ इतिहास ९, मर्कूस ९, भजनसंग्रh ६０, भजनसंग्रh ६１",
    "१ इतिहास १०, मर्कूस १०, भजनसंग्रh ६２, भजनसंग्रh ६３",
    "१ इतिहास ११, मर्कूस ११, भजनसंग्रh ६４, भजनसंग्रh ६５",
    "१ इतिहास १२, मर्कूस १२, भजनसंग्रh ६６, भजनसंग्रh ६７",
    "१ इतिहास १३, मर्कूस १३, भजनसंग्रh ६８, भजनसंग्रh ६९",
    "१ इतिहास १४, मर्कूस १४, भजनसंग्रh ७०, भजनसंग्रh ७１",
    "१ इतिहास १५, मर्कूस १५, भजनसंग्रh ७２, भजनसंग्रh ७३",
    "१ इतिहास १६, मर्कूस १६, भजनसंग्रh ७４, भजनसंग्रh ७５",
    "१ इतिहास १७, लूका १:१-३८, भजनसंग्रh ७６, भजनसंग्रh ७７",
    "१ इतिहास १८, लूका १:३९-८०, हितोपदेश १०, भजनसंग्रh ७८",
    "१ इतिहास १९, लूका २, हितोपदेश ११, भजनसंग्रh ७९",
    "१ इतिहास २०, लूका ३, हितोपदेश १२, भजनसंग्रh ८０",
    "१ इतिहास २１, लूका ४, हितोपदेश १३, भजनसंग्रh ८１",
    "१ इतिहास २２, लूका ५, हितोपदेश १४, भजनसंग्रh ८２",
    "१ इतिहास ২৩, लूका ६, हितोपदेश १५, भजनसंग्रh ८３",
    "१ इतिहास २४, लूका ७, हितोपदेश १६, भजनसंग्रh ८４",
    "१ इतिहास २५, लूका ८, हितोपदेश १७, भजनसंग्रh ८５",
    "१ इतिहास २６, लूका ९, हितोपदेश १८, भजनसंग्रh ८６",
    "१ इतिहास २७, लूका १०, हितोपदेश १९, भजनसंग्रh ८７",
    "१ इतिहास २８, लूका ११, हितोपदेश २०, भजनसंग्रh ८８",
    "१ इतिहास २९, लूका १२, हितोपदेश २१, भजनसंग्रh ८९",
    "२ इतिहास १, लूका १३, हितोपदेश २२, भजनसंग्रh ९０",
    "२ इतिहास २, लूका १४, हितोपदेश ২৩, भजनसंग्रh ९１",
    "२ इतिहास ३, लूका १५, हितोपदेश २४, भजनसंग्रh ९２",
    "२ इतिहास ४, लूका १६, हितोपदेश २५, भजनसंग्रh ९３",
    "२ इतिहास ५, लूका १७, हितोपदेश २６, भजनसंग्रh ९４",
    "२ इतिहास ६, लूका १८, हितोपदेश २७, भजनसंग्रh ९５",
    "२ इतिहास ७, लूका १९, हितोपदेश २८, भजनसंग्रh ९６",
    "२ इतिहास ८, लूका २०, हितोपदेश २९, भजनसंग्रh ९７",
    "२ इतिहास ९, लूका २１, हितोपदेश ३０, भजनसंग्रh ९８",
    "२ इतिहास १०, लूका २２, हितोपदेश ३１, भजनसंग्रh ९९",
    "२ इतिहास ११, लूका ২৩, भजनसंग्रh १०४, भजनसंग्रh १००",
    "२ इतिहास १२, लूका २४, भजनसंग्रh १०५, भजनसंग्रh १०१",
    "२ इतिहास १३, यूहन्ना १, भजनसंग्रh १०６, भजनसंग्रh १०２",
    "२ इतिहास १४, यूहन्ना २, भजनसंग्रh १०७, भजनसंग्रh १०३",
    "२ इतिहास १५, यूहन्ना ३, भजनसंग्रh १०८, भजनसंग्रh १०९",
    "२ इतिहास १६, यूहन्ना ४, भजनसंग्रh १１０, भजनसंग्रh ११１",
    "२ इतिहास १७, यूहन्ना ५, भजनसंग्रh १１２, भजनसंग्रh ११३",
    "२ इतिहास १८, यूहन्ना ६, भजनसंग्रh १１４, भजनसंग्रh ११५",
    "२ इतिहास १९, यूहन्ना ७, भजनसंग्रh १１６, भजनसंग्रh ११७",
    "२ इतिहास २०, यूहन्ना ८, भजनसंग्रh १１８, भजनसंग्रh ११९:१-३२",
    "२ इतिहास २१, यूहन्ना ९, भजनसंग्रh ११९:३३-６४, भजनसंग्रh ११९:६५-९६",
    "२ इतिहास २２, यूहन्ना १०, भजनसंग्रh ११९:९७-१२८, भजनसंग्रh ११९:१२९-१५２",
    "२ इतिहास ২৩, यूहन्ना ११, भजनसंग्रh ११९:१५३-१७६, भजनसंग्रh १२०",
    "२ इतिहास २४, यूहन्ना १२, भजनसंग्रh १२１, भजनसंग्रh १२２",
    "२ इतिहास २५, यूहन्ना १३, भजनसंग्रh १२３, भजनसंग्रh १२４",
    "२ इतिहास २６, यूहन्ना १४, भजनसंग्रh १२５, भजनसंग्रh १२６",
    "२ इतिहास २७, यूहन्ना १५, भजनसंग्रh १२７, भजनसंग्रh १२８",
    "२ इतिहास २８, यूहन्ना १६, भजनसंग्रh १२९, भजनसंग्रh १३０",
    "२ इतिहास २९, यूहन्ना १७, भजनसंग्रh १३１, भजनसंग्रh १३２",
    "२ इतिहास ३０, यूहन्ना १८, भजनसंग्रh १३３, भजनसंग्रh १३４",
    "२ इतिहास ३１, यूहन्ना १९, भजनसंग्रh १३５, भजनसंग्रh १३６",
    "२ इतिहास ३２, यूहन्ना २०, भजनसंग्रh १३７, भजनसंग्रh १३８",
    "२ इतिहास ३３, यूहन्ना २１, भजनसंग्रh १३９, भजनसंग्रh १४０",
    "२ इतिहास ३４, प्रेरित १, भजनसंग्रh १४１, भजनसंग्रh १४２",
    "२ इतिहास ३５, प्रेरित २, भजनसंग्रh १४３, भजनसंग्रh १४４",
    "२ इतिहास ३６, प्रेरित ३, भजनसंग्रh १४५, भजनसंग्रh १४６",
    "एज्रा १, प्रेरित ४, भजनसंग्रh १४７, भजनसंग्रh १४８",
    "एज्रा २, प्रेरित ५, भजनसंग्रh १४९, भजनसंग्रh १५０",
];


// --- Helper Functions ---
const formatDate = (timestamp: Timestamp | Date | undefined): string => {
    if (!timestamp) return '';
    const date = (timestamp as Timestamp).toDate ? (timestamp as Timestamp).toDate() : (timestamp as Date);
    return date.toLocaleDateString('ne-NP', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
    });
};
const formatTime = (timestamp: Timestamp | undefined): string => {
    if (!timestamp) return '';
    return timestamp.toDate().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
};
const formatRelativeTime = (timestamp: Timestamp | undefined): string => {
    if (!timestamp) return 'Just now';
    const now = new Date();
    const then = timestamp.toDate();
    const diffInSeconds = Math.floor((now.getTime() - then.getTime()) / 1000);

    if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
    if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
    return formatDate(timestamp);
};
function getAvatarInitial(name: string | undefined | null): string {
    if (!name) return 'L';
    const parts = name.split(' ');
    if (parts.length > 1 && parts[parts.length - 1]) {
        return `${parts[0][0]}${parts[parts.length - 1][0]}`.toUpperCase();
    }
    return name.substring(0, 1).toUpperCase();
}
const getEmbedUrl = (url: string, muted: boolean = false): string | null => {
    if (!url) return null;
    try {
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|live\/)|youtu\.be\/)([\w-]{11})/;
        const youtubeMatch = url.match(youtubeRegex);
        if (youtubeMatch && youtubeMatch[1]) {
            const videoId = youtubeMatch[1];
            // Autoplay requires mute=1 in most modern browsers.
            return `https://www.youtube.com/embed/${videoId}?autoplay=1&playsinline=1${muted ? '&mute=1' : ''}`;
        }

        const facebookRegex = /https?:\/\/(?:www\.|web\.)?facebook\.com\/(?:watch\/?\?v=|.+?\/videos\/|video\.php\?v=)/;
         if (facebookRegex.test(url)) {
            return `https://www.facebook.com/plugins/video.php?href=${encodeURIComponent(url)}&show_text=0&autoplay=1`;
        }
        
        return null; 
    } catch (error) {
        console.error("Error parsing stream URL:", url, error);
        return null;
    }
};

/**
 * Compresses an image file before uploading.
 * @param {File} file The image file to compress.
 * @returns {Promise<File>} A promise that resolves with the compressed image file.
 */
const compressImage = (file: File): Promise<File> => {
    return new Promise((resolve, reject) => {
        const MAX_WIDTH = 1280;
        const MAX_HEIGHT = 1280;
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (event) => {
            const img = new Image();
            img.src = event.target?.result as string;
            img.onload = () => {
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > MAX_WIDTH) {
                        height *= MAX_WIDTH / width;
                        width = MAX_WIDTH;
                    }
                } else {
                    if (height > MAX_HEIGHT) {
                        width *= MAX_HEIGHT / height;
                        height = MAX_HEIGHT;
                    }
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    return reject(new Error("Could not get canvas context"));
                }
                ctx.drawImage(img, 0, 0, width, height);
                canvas.toBlob(
                    (blob) => {
                        if (blob) {
                            const newFile = new File([blob], file.name, {
                                type: 'image/jpeg',
                                lastModified: Date.now(),
                            });
                            resolve(newFile);
                        } else {
                            reject(new Error("Canvas to Blob conversion failed"));
                        }
                    },
                    'image/jpeg',
                    0.85 // Quality setting
                );
            };
            img.onerror = (error) => reject(error);
        };
        reader.onerror = (error) => reject(error);
    });
};


// --- React Components ---

const ErrorFallback: React.FC<{ error: Error }> = ({ error }) => (
    <div className="error-container">
        <img src={CHURCH.logo} alt="Church Logo" className="error-logo" />
        <h2>Oops! Something went wrong.</h2>
        <p>We're sorry, but the application encountered an unexpected error. Please try again later.</p>
        <pre>{error.message}</pre>
    </div>
);

const SplashScreen: React.FC = () => (
    <div className="splash-screen-container">
        <img src={CHURCH.logo} alt="Church Logo" className="splash-logo" />
        <div className="splash-spinner"></div>
    </div>
);

const Loading: React.FC<{ message?: string }> = ({ message = 'Loading...' }) => (
    <div className="loading-container">
        <div className="spinner"></div>
        <span>{message}</span>
    </div>
);

const Fab: React.FC<{ onClick: () => void; icon: string, 'aria-label': string }> = ({ onClick, icon, 'aria-label': ariaLabel }) => (
    <button className="fab" onClick={onClick} aria-label={ariaLabel}>
        <span className="material-symbols-outlined">{icon}</span>
    </button>
);

const Modal: React.FC<{ 
    isOpen: boolean; 
    onClose: () => void; 
    children: React.ReactNode;
    position?: 'center' | 'bottom';
}> = ({ isOpen, onClose, children, position = 'center' }) => {
    if (!isOpen) return null;

    return createPortal(
        <div className={`modal-backdrop ${position === 'bottom' ? 'modal-is-bottom' : ''}`} onClick={onClose}>
            <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                {children}
            </div>
        </div>,
        document.body
    );
};


const ImageUpload: React.FC<{
    selectedFile: File | null;
    setSelectedFile: (file: File | null) => void;
    currentImageUrl?: string | null;
    label?: string;
}> = ({ selectedFile, setSelectedFile, currentImageUrl, label = 'Add a photo' }) => {
    const [preview, setPreview] = useState<string | null>(currentImageUrl ?? null);
    const fileInputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (selectedFile) {
            const objectUrl = URL.createObjectURL(selectedFile);
            setPreview(objectUrl);
            return () => URL.revokeObjectURL(objectUrl);
        } else {
            setPreview(currentImageUrl ?? null);
        }
    }, [selectedFile, currentImageUrl]);

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0]) {
            setSelectedFile(e.target.files[0]);
        }
    };

    const handleRemoveImage = () => {
        setSelectedFile(null);
        setPreview(null);
        if (fileInputRef.current) {
            fileInputRef.current.value = "";
        }
    };
    
    return (
        <div className="image-upload-container">
            {preview ? (
                <div className="image-preview">
                    <img src={preview} alt="Preview" />
                    <button type="button" onClick={handleRemoveImage} aria-label="Remove image">
                         <span className="material-symbols-outlined">close</span>
                    </button>
                </div>
            ) : (
                <label htmlFor="image-upload" className="image-upload-label">
                     <span className="material-symbols-outlined">add_photo_alternate</span>
                    <span>{label}</span>
                    <input
                        id="image-upload"
                        type="file"
                        accept="image/*"
                        onChange={handleFileChange}
                        ref={fileInputRef}
                        style={{ display: 'none' }}
                    />
                </label>
            )}
        </div>
    );
};


const LoginPage: React.FC = () => {
    const { auth } = useFirebase();
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [name, setName] = useState('');
    const [isRegistering, setIsRegistering] = useState(false);

    const handleEmailAuth = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        setError('');
        try {
            if (isRegistering) {
                if (!name.trim()) { setError('Please enter your name.'); return; }
                const userCredential = await createUserWithEmailAndPassword(auth!, email, password);
                await updateProfile(userCredential.user, { displayName: name });
            } else {
                await signInWithEmailAndPassword(auth!, email, password);
            }
        } catch (err: any) {
            let friendlyMessage = err.message;
            if (err.code === 'auth/weak-password') {
                friendlyMessage = 'Password should be at least 6 characters.';
            } else if (err.code === 'auth/email-already-in-use') {
                friendlyMessage = 'This email is already in use. Please log in.';
            } else if (err.code === 'auth/invalid-credential') {
                 friendlyMessage = 'Incorrect email or password.';
            }
            setError(friendlyMessage);
        } finally {
            setLoading(false);
        }
    };

    const handleGoogleSignIn = async () => {
        if (!auth) return;
        setLoading(true);
        setError('');
        try {
            const provider = new GoogleAuthProvider();
            await signInWithPopup(auth, provider);
        } catch (err: any) {
            // Don't show an error if the user closes the sign-in popup.
            if (err.code !== 'auth/popup-closed-by-user') {
                setError(err.message);
            }
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="login-container">
            <div className="login-box">
                <img src={CHURCH.logo} alt="Church Logo" className="login-logo" />
                <h2>{isRegistering ? 'Create Account' : 'Welcome Back'}</h2>
                <p>{CHURCH.name}</p>

                <form onSubmit={handleEmailAuth}>
                    {isRegistering && (
                        <input type="text" className="login-input" placeholder="Full Name" value={name} onChange={(e) => setName(e.target.value)} required />
                    )}
                    <input type="email" className="login-input" placeholder="Email Address" value={email} onChange={(e) => setEmail(e.target.value)} required autoComplete="email" />
                    <input 
                        type="password" 
                        className="login-input" 
                        placeholder="Password" 
                        value={password} 
                        onChange={(e) => setPassword(e.target.value)} 
                        required 
                        minLength={6}
                        autoComplete={isRegistering ? "new-password" : "current-password"} 
                    />
                    <button type="submit" className="login-button" disabled={loading}>
                        {loading ? <div className="spinner"></div> : (isRegistering ? 'Sign Up' : 'Log In')}
                    </button>
                    <button type="button" onClick={() => { setIsRegistering(!isRegistering); setError(''); }} className="auth-toggle-link">
                        {isRegistering ? 'Already have an account? Log In' : "Don't have an account? Sign Up"}
                    </button>
                </form>

                <div className="login-divider"><span>OR</span></div>
                
                <button onClick={handleGoogleSignIn} className="google-signin-button" disabled={loading}>
                    <svg viewBox="0 0 48 48" width="24px" height="24px">
                        <path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path>
                        <path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path>
                        <path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path>
                        <path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path>
                        <path fill="none" d="M0 0h48v48H0z"></path>
                    </svg>
                    <span>Sign in with Google</span>
                </button>

                {error && <p className="login-error">{error}</p>}
            </div>
        </div>
    );
};

// --- Main App Pages ---
const WorshipPage: React.FC<{
    currentUser: User;
    liveService: WorshipService | null;
    pastServices: PastWorshipService[];
}> = ({ currentUser, liveService, pastServices }) => {
    const { db } = useFirebase();
    const [isOfferingModalOpen, setIsOfferingModalOpen] = useState(false);
    const [isAddPastWorshipModalOpen, setIsAddPastWorshipModalOpen] = useState(false);
    const [newPastService, setNewPastService] = useState({ title: '', youtubeUrl: '' });
    const [playingPastService, setPlayingPastService] = useState<PastWorshipService | null>(null);

    const liveEmbedUrl = liveService?.streamUrl ? getEmbedUrl(liveService.streamUrl) : null;
    const playingEmbedUrl = playingPastService?.youtubeUrl ? getEmbedUrl(playingPastService.youtubeUrl, true) : null;

    const handleAddPastService = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!db || !newPastService.title || !newPastService.youtubeUrl) return;
        
        try {
            await addDoc(collection(db, "pastWorshipServices"), {
                ...newPastService,
                createdAt: serverTimestamp()
            });
            setNewPastService({ title: '', youtubeUrl: '' });
            setIsAddPastWorshipModalOpen(false);
        } catch (error) {
            console.error("Error adding past worship service: ", error);
        }
    };

    const handleDeletePastService = async (serviceId: string) => {
        if (!db || !window.confirm("Are you sure you want to delete this past service?")) return;
        try {
            await deleteDoc(doc(db, "pastWorshipServices", serviceId));
        } catch (error) {
            console.error("Error deleting past service:", error);
        }
    }

    const getYoutubeThumbnail = (url: string) => {
        try {
            const videoIdMatch = url.match(/(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/);
            const videoId = videoIdMatch ? videoIdMatch[1] : null;
            return videoId ? `https://img.youtube.com/vi/${videoId}/hqdefault.jpg` : '/placeholder.jpg';
        } catch {
            return '/placeholder.jpg';
        }
    };

    const renderPlayer = () => {
        if (liveService && liveEmbedUrl) {
            return (
                <div className="card live-worship-card">
                    <div className="live-badge">LIVE</div>
                    <div className="iframe-container">
                        <iframe src={liveEmbedUrl} allow="autoplay; encrypted-media" allowFullScreen={true} title="Live Worship Stream"></iframe>
                    </div>
                    <h4>{liveService.title}</h4>
                </div>
            );
        }
        if (playingPastService && playingEmbedUrl) {
             return (
                <div className="card live-worship-card">
                    <div className="iframe-container">
                        <iframe src={playingEmbedUrl} allow="autoplay; encrypted-media" allowFullScreen={true} title={playingPastService.title}></iframe>
                    </div>
                    <div className="playing-past-service-info">
                        <h4>{playingPastService.title}</h4>
                        <button className="close-player-button" onClick={() => setPlayingPastService(null)}>
                             <span className="material-symbols-outlined">close</span> Player बन्द गर्नुहोस्
                        </button>
                    </div>
                </div>
            );
        }
        return (
            <div className="card no-live-service">
                <span className="material-symbols-outlined">church</span>
                <p>अहिले कुनै प्रत्यक्ष आरधना छैन।</p>
            </div>
        );
    };

    return (
        <div className="page-content">
            <h2>आरधना</h2>
            {renderPlayer()}
            
             <div className="worship-actions">
                <button className="action-button" onClick={() => setIsOfferingModalOpen(true)}>
                    <span className="material-symbols-outlined">volunteer_activism</span>
                    अनलाइन भेटी
                </button>
            </div>
            <div className="past-worship-section">
                <h3>विगतका आरधना</h3>
                {currentUser.roles.includes('admin') && (
                    <button className="action-button add-past-worship-button" onClick={() => setIsAddPastWorshipModalOpen(true)}>
                        <span className="material-symbols-outlined">add</span> विगतका आरधना थप्नुहोस्।
                    </button>
                )}
                <div className="past-worship-list">
                    {pastServices.map(service => (
                        <div key={service.id} className="card past-service-card" onClick={() => setPlayingPastService(service)}>
                            <img 
                                src={getYoutubeThumbnail(service.youtubeUrl)}
                                alt={service.title}
                                className="past-service-thumbnail"
                                loading="lazy"
                            />
                            <div className="play-icon-overlay">
                                <span className="material-symbols-outlined">play_circle</span>
                            </div>
                            <p className="past-service-title">{service.title}</p>
                            {currentUser.roles.includes('admin') && (
                                <button
                                    className="delete-button past-service-delete-button"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDeletePastService(service.id);
                                    }}
                                    aria-label="Delete past service"
                                >
                                    <span className="material-symbols-outlined">delete</span>
                                </button>
                             )}
                        </div>
                    ))}
                </div>
            </div>

            <Modal isOpen={isOfferingModalOpen} onClose={() => setIsOfferingModalOpen(false)}>
                <div className="offering-modal-content">
                    <h3>Online Offering</h3>
                    <img src={CHURCH.offeringDetails.qrCodeUrl} alt="QR Code for offering" className="qr-code-img" />
                    <div className="offering-details">
                        <p><strong>Bank:</strong> {CHURCH.offeringDetails.bankName}</p>
                        <p><strong>Account Holder:</strong> {CHURCH.offeringDetails.accountHolder}</p>
                        <div className="account-number-container">
                            <p><strong>Account Number:</strong> {CHURCH.offeringDetails.accountNumber}</p>
                            <button
                                className="copy-button"
                                onClick={() => {
                                    navigator.clipboard.writeText(CHURCH.offeringDetails.accountNumber);
                                    alert('Account number copied!');
                                }}
                            >
                                <span className="material-symbols-outlined">content_copy</span> Copy
                            </button>
                        </div>
                    </div>
                </div>
            </Modal>
             <Modal isOpen={isAddPastWorshipModalOpen} onClose={() => setIsAddPastWorshipModalOpen(false)}>
                <form className="modal-form" onSubmit={handleAddPastService}>
                    <h3>Add Past Service</h3>
                    <input
                        type="text"
                        placeholder="Service Title"
                        value={newPastService.title}
                        onChange={(e) => setNewPastService({ ...newPastService, title: e.target.value })}
                        required
                    />
                    <input
                        type="url"
                        placeholder="YouTube URL"
                        value={newPastService.youtubeUrl}
                        onChange={(e) => setNewPastService({ ...newPastService, youtubeUrl: e.target.value })}
                        required
                    />
                    <div className="form-actions">
                        <button type="submit" className="action-button">Save</button>
                        <button type="button" className="action-button secondary" onClick={() => setIsAddPastWorshipModalOpen(false)}>Cancel</button>
                    </div>
                </form>
            </Modal>
        </div>
    );
};


const BiblePage: React.FC = () => {
    const [verseOfTheDay, setVerseOfTheDay] = useState<Verse | null>(null);
    const dayOfMonth = new Date().getDate();

    useEffect(() => {
        const dayOfYear = Math.floor((new Date().getTime() - new Date(new Date().getFullYear(), 0, 0).getTime()) / (1000 * 60 * 60 * 24));
        setVerseOfTheDay(MOCK_VERSES_OF_THE_DAY[dayOfYear % MOCK_VERSES_OF_THE_DAY.length]);
    }, []);

    const getDayOfYear = () => {
         const now = new Date();
         const start = new Date(now.getFullYear(), 0, 0);
         const diff = (now.getTime() - start.getTime()) + ((start.getTimezoneOffset() - now.getTimezoneOffset()) * 60 * 1000);
         const oneDay = 1000 * 60 * 60 * 24;
         return Math.floor(diff / oneDay);
    };

    const todayReading = MCCHEYNE_READING_PLAN[getDayOfYear() -1] || MCCHEYNE_READING_PLAN[0];

    return (
        <div className="page-content">
            <h2>बाइबल</h2>
            <div className="list-container bible-card-list">
                {verseOfTheDay && (
                    <div className="card verse-card">
                        <p className="verse-text">"{verseOfTheDay.text}"</p>
                        <p className="verse-ref">- {verseOfTheDay.verse}</p>
                    </div>
                )}
                
                <div className="card bible-card">
                    <h3>आजको बाइबल पढ्ने योजना</h3>
                    <p>{todayReading}</p>
                </div>
                
                <div className="card bible-card">
                    <h3>आजको हितोपदेश</h3>
                    <p>आज {dayOfMonth} तारिख हो, हितोपदेश {dayOfMonth} अध्याय पढ्नुहोस्।</p>
                </div>
            </div>
        </div>
    );
};

const NewsPage: React.FC<{ 
    currentUser: User; 
    news: NewsItem[];
    setNews: React.Dispatch<React.SetStateAction<NewsItem[]>>
}> = ({ currentUser, news, setNews }) => {
    const { db, storage } = useFirebase();
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingNews, setEditingNews] = useState<NewsItem | null>(null);

    const handleOpenModal = (newsItem: NewsItem | null = null) => {
        setEditingNews(newsItem);
        setIsModalOpen(true);
    };

    const handleCloseModal = () => {
        setEditingNews(null);
        setIsModalOpen(false);
    };

    const handleSaveNews = (title: string, content: string, imageFile: File | null) => {
        if (!db || !storage || !currentUser) return;
    
        const tempId = crypto.randomUUID();
        const optimisticNews: NewsItem = {
            id: tempId,
            tempId,
            title,
            content,
            authorId: currentUser.id,
            authorName: currentUser.name,
            createdAt: Timestamp.now(),
            status: 'uploading',
            localImagePreview: imageFile ? URL.createObjectURL(imageFile) : (editingNews?.image || undefined),
        };
    
        if (editingNews) {
            setNews(prev => prev.map(n => n.id === editingNews.id ? { ...optimisticNews, id: editingNews.id } : n));
        } else {
            setNews(prev => [optimisticNews, ...prev]);
        }
    
        const performSave = async () => {
            try {
                let finalImageUrl: string | null = editingNews?.image || null;
    
                if (imageFile) {
                    if (editingNews?.image) {
                        try {
                            await deleteObject(ref(storage, editingNews.image));
                        } catch (error) { console.warn("Could not delete old news image:", error); }
                    }
                    const compressedFile = await compressImage(imageFile);
                    const imageRef = ref(storage, `news/${Date.now()}_${compressedFile.name}`);
                    await uploadBytes(imageRef, compressedFile);
                    finalImageUrl = await getDownloadURL(imageRef);
                }
    
                const payload = { title, content, authorId: currentUser.id, authorName: currentUser.name, image: finalImageUrl };
    
                if (editingNews) {
                    await updateDoc(doc(db, "news", editingNews.id), payload);
                } else {
                    await addDoc(collection(db, "news"), { ...payload, createdAt: serverTimestamp() });
                }
            } catch (error: any) {
                console.error("❌ Failed to save news. Error Code:", error.code);
                console.error("❌ Failed to save news. Error Message:", error.message);
                console.error("❌ Full Error:", error);
                setNews(prev => prev.map(n => n.tempId === tempId ? { ...n, status: 'failed' } : n));
            }
        };
    
        performSave();
    };

    const handleDeleteNews = async (newsItem: NewsItem) => {
        if (!db || !storage) return;
        if (!window.confirm(`Are you sure you want to delete "${newsItem.title}"?`)) return;

        try {
            if (newsItem.image) {
                const imageRef = ref(storage, newsItem.image);
                await deleteObject(imageRef).catch(error => {
                    if (error.code !== 'storage/object-not-found') {
                        console.error("Error deleting image from storage:", error);
                    }
                });
            }
            await deleteDoc(doc(db, "news", newsItem.id));
        } catch (error) {
            console.error("Error deleting news item: ", error);
        }
    };

    const canPostNews = currentUser.roles.includes('admin') || currentUser.roles.includes('news_contributor');
    const canManagePost = (item: NewsItem) => currentUser.id === item.authorId || currentUser.roles.includes('admin');

    return (
        <div className="page-content">
            <h2>सुचना</h2>
            <div className="list-container">
                {news.map(item => (
                    <div key={item.tempId || item.id} className="card news-item">
                         {item.status && (
                            <div className="upload-status-overlay">
                                {item.status === 'uploading' ? <div className="spinner"></div> : <span>&#x26A0;</span>}
                            </div>
                        )}
                        {(item.localImagePreview || item.image) && <img src={item.localImagePreview || item.image || ''} alt={item.title} className="news-image" loading="lazy" />}
                        <div className="news-content">
                            <div className="news-header">
                                <h3>{item.title}</h3>
                                {canManagePost(item) && (
                                    <div className="item-actions-header">
                                        <button onClick={() => handleOpenModal(item)} className="edit-button" aria-label="Edit news">
                                            <span className="material-symbols-outlined">edit</span>
                                        </button>
                                        <button onClick={() => handleDeleteNews(item)} className="delete-button" aria-label="Delete news">
                                            <span className="material-symbols-outlined">delete</span>
                                        </button>
                                    </div>
                                )}
                            </div>
                            <p className="news-meta">By {item.authorName} on {formatDate(item.createdAt)}</p>
                            <p>{item.content}</p>
                        </div>
                    </div>
                ))}
            </div>
            {canPostNews && <Fab onClick={() => handleOpenModal()} icon="feed" aria-label="Add news" />}

            <NewsFormModal
                isOpen={isModalOpen}
                onClose={handleCloseModal}
                onSave={handleSaveNews}
                newsItem={editingNews}
            />
        </div>
    );
};

const NewsFormModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    onSave: (title: string, content: string, imageFile: File | null) => void;
    newsItem: NewsItem | null;
}> = ({ isOpen, onClose, onSave, newsItem }) => {
    const [title, setTitle] = useState('');
    const [content, setContent] = useState('');
    const [imageFile, setImageFile] = useState<File | null>(null);
    
    useEffect(() => {
        if (isOpen) {
            setTitle(newsItem?.title || '');
            setContent(newsItem?.content || '');
            setImageFile(null); // Reset file input on open
        }
    }, [isOpen, newsItem]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave(title, content, imageFile);
        onClose();
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <form className="modal-form" onSubmit={handleSubmit}>
                <button type="button" className="modal-close-button" onClick={onClose} aria-label="Close">
                     <span className="material-symbols-outlined">close</span>
                </button>
                <h3>{newsItem ? 'सुचना सम्पादन गर्नुहोस्' : 'सुचना थप्नुहोस्।'}</h3>
                <input
                    type="text"
                    placeholder="शीर्षक"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    required
                />
                <textarea
                    placeholder="सामग्री"
                    rows={5}
                    value={content}
                    onChange={(e) => setContent(e.target.value)}
                    required
                ></textarea>
                <ImageUpload 
                    selectedFile={imageFile} 
                    setSelectedFile={setImageFile} 
                    currentImageUrl={newsItem?.image}
                    label="फोटो थप्नुहोस्।(यदि तपाईं चाहनुहुन्छ भने)"
                />

                <div className="form-actions">
                    <button type="submit" className="action-button">
                        सेभ गर्नुहोस्
                    </button>
                </div>
            </form>
        </Modal>
    );
};

const PodcastsPage: React.FC<{
    currentUser: User, 
    podcasts: Podcast[],
    setPodcasts: React.Dispatch<React.SetStateAction<Podcast[]>>
}> = ({currentUser, podcasts, setPodcasts}) => {
    const { db, storage } = useFirebase();
    const [isModalOpen, setIsModalOpen] = useState(false);

    const handleSavePodcast = (title: string, audioFile: File) => {
        if (!db || !storage || !currentUser) return;
    
        const tempId = crypto.randomUUID();
        const optimisticPodcast: Podcast = {
            id: tempId,
            tempId,
            title,
            authorId: currentUser.id,
            authorName: currentUser.name,
            audioUrl: '', // Will be filled later
            createdAt: Timestamp.now(),
            status: 'uploading',
            localAudioUrl: URL.createObjectURL(audioFile),
        };
    
        setPodcasts(prev => [optimisticPodcast, ...prev]);
    
        const performSave = async () => {
            try {
                const audioRef = ref(storage, `podcasts/${Date.now()}_${audioFile.name}`);
                await uploadBytes(audioRef, audioFile);
                const audioUrl = await getDownloadURL(audioRef);
    
                await addDoc(collection(db, "podcasts"), {
                    title,
                    audioUrl,
                    authorId: currentUser.id,
                    authorName: currentUser.name,
                    createdAt: serverTimestamp(),
                });
            } catch (error: any) {
                console.error("❌ Failed to save podcast. Error Code:", error.code);
                console.error("❌ Failed to save podcast. Error Message:", error.message);
                console.error("❌ Full Error:", error);
                setPodcasts(prev => prev.map(p => p.tempId === tempId ? { ...p, status: 'failed' } : p));
            }
        };
    
        performSave();
    };
    
    const handleDeletePodcast = async (podcast: Podcast) => {
        if(!db || !storage) return;
        if (!window.confirm(`Are you sure you want to delete "${podcast.title}"?`)) return;

        try {
            const audioRef = ref(storage, podcast.audioUrl);
            await deleteObject(audioRef);
            await deleteDoc(doc(db, "podcasts", podcast.id));
        } catch (error) {
            console.error("Error deleting podcast: ", error);
        }
    };

    const canPostPodcast = currentUser.roles.includes('admin') || currentUser.roles.includes('podcast_contributor');
    const canManagePodcast = (podcast: Podcast) => currentUser.id === podcast.authorId || currentUser.roles.includes('admin');

    return (
        <div className="page-content">
            <h2>Podcast</h2>
            <div className="list-container">
                {podcasts.map(podcast => (
                    <div key={podcast.tempId || podcast.id} className="card podcast-item">
                        {podcast.status && (
                            <div className="upload-status-overlay">
                                {podcast.status === 'uploading' ? <div className="spinner"></div> : <span>&#x26A0;</span>}
                            </div>
                        )}
                        <div className="podcast-info">
                            <div>
                                <p className="podcast-title">{podcast.title}</p>
                                <p className="podcast-author">By {podcast.authorName} - {formatDate(podcast.createdAt)}</p>
                            </div>
                            {canManagePodcast(podcast) && (
                                <button onClick={() => handleDeletePodcast(podcast)} className="delete-button" aria-label="Delete podcast">
                                    <span className="material-symbols-outlined">delete</span>
                                </button>
                            )}
                        </div>
                        <audio controls className="podcast-player" src={podcast.localAudioUrl || podcast.audioUrl}>
                            Your browser does not support the audio element.
                        </audio>
                    </div>
                ))}
            </div>
            {canPostPodcast && <Fab onClick={() => setIsModalOpen(true)} icon="podcasts" aria-label="Add podcast" />}

            <AddPodcastModal
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                onSave={handleSavePodcast}
            />
        </div>
    );
};

const AddPodcastModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    onSave: (title: string, audioFile: File) => void;
}> = ({ isOpen, onClose, onSave }) => {
    const [title, setTitle] = useState('');
    const [audioFile, setAudioFile] = useState<File | null>(null);
    const [activeTab, setActiveTab] = useState<'upload' | 'record'>('upload');
    
    // Recording state
    const [isRecording, setIsRecording] = useState(false);
    const [recordingTime, setRecordingTime] = useState(0);
    const [recordedBlob, setRecordedBlob] = useState<Blob | null>(null);
    const [recordedAudioUrl, setRecordedAudioUrl] = useState<string | null>(null);
    const mediaRecorderRef = useRef<MediaRecorder | null>(null);
    const mediaStreamRef = useRef<MediaStream | null>(null);
    const timerIntervalRef = useRef<number | null>(null);

    useEffect(() => {
        if (recordedBlob) {
            const url = URL.createObjectURL(recordedBlob);
            setRecordedAudioUrl(url);
            return () => URL.revokeObjectURL(url);
        }
        setRecordedAudioUrl(null);
    }, [recordedBlob]);

    const handleStartRecording = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaStreamRef.current = stream;
            mediaRecorderRef.current = new MediaRecorder(stream);
            const chunks: Blob[] = [];
            
            mediaRecorderRef.current.ondataavailable = (e: BlobEvent) => {
                chunks.push(e.data);
            };
            
            mediaRecorderRef.current.onstop = () => {
                const blob = new Blob(chunks, { type: 'audio/webm' });
                setRecordedBlob(blob);
                const audioFile = new File([blob], "recording.webm", { type: 'audio/webm' });
                setAudioFile(audioFile);
                if (mediaStreamRef.current) {
                    mediaStreamRef.current.getTracks().forEach(track => track.stop());
                }
            };
            
            mediaRecorderRef.current.start();
            setIsRecording(true);
            timerIntervalRef.current = window.setInterval(() => {
                setRecordingTime(prev => prev + 1);
            }, 1000);
        } catch (error) {
            console.error("Error starting recording:", error);
            alert("Could not start microphone. Please check browser or phone settings for mic permission for this site.");
        }
    };
    
    const handleStopRecording = () => {
        if (mediaRecorderRef.current) {
            mediaRecorderRef.current.stop();
            setIsRecording(false);
            if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
            setRecordingTime(0);
        }
    };

    const handleResetRecording = () => {
        setRecordedBlob(null);
        setAudioFile(null);
        setRecordingTime(0);
    }
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (!audioFile || !title.trim()) {
            alert("Please provide a title and select or record an audio file.");
            return;
        }
        onSave(title, audioFile);
        setTitle('');
        setAudioFile(null);
        handleResetRecording();
        onClose();
    };

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = (seconds % 60).toString().padStart(2, '0');
        return `${mins}:${secs}`;
    };

    return (
         <Modal isOpen={isOpen} onClose={onClose}>
            <form className="modal-form" onSubmit={handleSubmit}>
                <button type="button" className="modal-close-button" onClick={onClose} aria-label="Close">
                     <span className="material-symbols-outlined">close</span>
                </button>
                <h3>Add Podcast</h3>

                <div className="add-podcast-tabs">
                    <button type="button" className={activeTab === 'upload' ? 'active' : ''} onClick={() => setActiveTab('upload')}>Upload</button>
                    <button type="button" className={activeTab === 'record' ? 'active' : ''} onClick={() => setActiveTab('record')}>Record</button>
                </div>

                <input
                    type="text"
                    placeholder="Podcast Title"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    required
                />
                
                {activeTab === 'upload' && (
                     <label htmlFor="audio-upload" className="action-button secondary custom-file-input">
                        <span className="material-symbols-outlined">upload_file</span>
                        <span>{audioFile ? audioFile.name : 'Choose Audio File'}</span>
                         <input
                            id="audio-upload"
                            type="file"
                            accept="audio/*"
                            onChange={(e) => e.target.files && setAudioFile(e.target.files[0])}
                            style={{ display: 'none' }}
                        />
                    </label>
                )}

                {activeTab === 'record' && (
                    <div className="record-section">
                        <p className="permission-helper-text">
                           Microphone permission is required to start recording. A prompt will appear when you press the 'Start Recording' button.
                        </p>
                        {!recordedBlob ? (
                             <button type="button" className={`record-button ${isRecording ? 'recording' : ''}`} onClick={isRecording ? handleStopRecording : handleStartRecording}>
                                <span className="material-symbols-outlined">{isRecording ? 'stop_circle' : 'mic'}</span>
                                {isRecording ? <span className="timer">{formatTime(recordingTime)}</span> : 'Start Recording'}
                            </button>
                        ) : (
                             <div className="recording-preview">
                                <p>Recording complete:</p>
                                {recordedAudioUrl && <audio controls src={recordedAudioUrl}></audio>}
                                <button type="button" className="action-button secondary" onClick={handleResetRecording}>Record Again</button>
                            </div>
                        )}
                    </div>
                )}
                
                <div className="form-actions">
                    <button type="submit" className="action-button" disabled={!audioFile}>
                        Save Podcast
                    </button>
                </div>
            </form>
        </Modal>
    );
};


const PrayerPage: React.FC<{ 
    currentUser: User; 
    requests: PrayerRequest[];
    setRequests: React.Dispatch<React.SetStateAction<PrayerRequest[]>>;
}> = ({ currentUser, requests, setRequests }) => {
    const { db, storage } = useFirebase();
    const [selectedRequest, setSelectedRequest] = useState<PrayerRequest | null>(null);
    const [isAddModalOpen, setIsAddModalOpen] = useState(false);
    const [editingRequest, setEditingRequest] = useState<PrayerRequest | null>(null);

    const handleTogglePrayed = async (request: PrayerRequest) => {
        if (!db || request.status) return; // Don't interact with uploading items
        const requestRef = doc(db, "prayerRequests", request.id);
        const alreadyPrayed = request.prayedBy.includes(currentUser.id);

        await updateDoc(requestRef, {
            prayedBy: alreadyPrayed ? arrayRemove(currentUser.id) : arrayUnion(currentUser.id)
        });
    };

    const handleOpenAddModal = (request: PrayerRequest | null = null) => {
        setEditingRequest(request);
        setIsAddModalOpen(true);
    };

    const handleCloseAddModal = () => {
        setIsAddModalOpen(false);
        setEditingRequest(null);
    };
    
    const handleSavePrayerRequest = (title: string, content: string, imageFile: File | null) => {
        if (!db || !storage || !currentUser) return;
    
        const tempId = crypto.randomUUID();
        const optimisticRequest: PrayerRequest = {
            id: tempId,
            tempId,
            title,
            content,
            authorId: currentUser.id,
            authorName: currentUser.name,
            prayedBy: editingRequest?.prayedBy || [],
            commentCount: editingRequest?.commentCount || 0,
            createdAt: Timestamp.now(),
            status: 'uploading',
            localImagePreview: imageFile ? URL.createObjectURL(imageFile) : (editingRequest?.image || undefined),
        };
    
        if (editingRequest) {
            setRequests(prev => prev.map(r => r.id === editingRequest.id ? { ...optimisticRequest, id: editingRequest.id } : r));
        } else {
            setRequests(prev => [optimisticRequest, ...prev]);
        }
    
        const performSave = async () => {
            try {
                let finalImageUrl: string | null = editingRequest?.image || null;
    
                if (imageFile) {
                    if (editingRequest?.image) {
                        try { await deleteObject(ref(storage, editingRequest.image)); } catch (e) { console.warn("Old image delete failed", e); }
                    }
                    const compressedFile = await compressImage(imageFile);
                    const imageRef = ref(storage, `prayers/${Date.now()}_${compressedFile.name}`);
                    await uploadBytes(imageRef, compressedFile);
                    finalImageUrl = await getDownloadURL(imageRef);
                }
    
                const payload = { title, content, authorId: currentUser.id, authorName: currentUser.name, image: finalImageUrl };
    
                if (editingRequest) {
                    await updateDoc(doc(db, "prayerRequests", editingRequest.id), payload);
                } else {
                    await addDoc(collection(db, "prayerRequests"), { ...payload, prayedBy: [], createdAt: serverTimestamp() });
                }
            } catch (error: any) {
                console.error("❌ Failed to save prayer request. Error Code:", error.code);
                console.error("❌ Failed to save prayer request. Error Message:", error.message);
                console.error("❌ Full Error:", error);
                setRequests(prev => prev.map(r => r.tempId === tempId ? { ...r, status: 'failed' } : r));
            }
        };
    
        performSave();
    };

    const handleDeleteRequest = async (request: PrayerRequest) => {
        if (!db || !storage || request.status) return;
        if (!window.confirm("Are you sure you want to delete this prayer request?")) return;

        try {
            if (request.image) {
                const imageRef = ref(storage, request.image);
                await deleteObject(imageRef).catch(e => console.error("Image delete failed", e));
            }
            await deleteDoc(doc(db, "prayerRequests", request.id));
            setSelectedRequest(null);
        } catch (error) {
            console.error("Error deleting prayer request: ", error);
        }
    };
    
    const handleShowDetails = (req: PrayerRequest) => {
        if(req.status) return; // Don't open details for uploading items
        setEditingRequest(req); // Set for potential edit/delete
        setSelectedRequest(req);
    };

    const canManageRequest = (req: PrayerRequest) => currentUser.id === req.authorId || currentUser.roles.includes('admin');

    return (
        <div className="page-content">
            <h2>प्रार्थना</h2>
            <div className="list-container">
                {requests.map(req => (
                    <div key={req.tempId || req.id} className="card prayer-item" onClick={() => handleShowDetails(req)}>
                        {req.status && (
                            <div className="upload-status-overlay">
                                {req.status === 'uploading' ? <div className="spinner"></div> : <span>&#x26A0;</span>}
                            </div>
                        )}
                        {(req.localImagePreview || req.image) && <img src={req.localImagePreview || req.image || ''} alt={req.title} className="prayer-image" loading="lazy" />}
                        <h4>{req.title}</h4>
                        <p className="prayer-content">{req.content}</p>
                        <div className="prayer-meta">
                            <span>By {req.authorName} - {formatRelativeTime(req.createdAt)}</span>
                            <div className="prayer-actions">
                                <button
                                    className={`prayer-action-button ${req.prayedBy.includes(currentUser.id) ? 'prayed' : ''}`}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleTogglePrayed(req);
                                    }}
                                >
                                    <span className="material-symbols-outlined">volunteer_activism</span>
                                    <span>{req.prayedBy.length}</span>
                                </button>
                                <div className="prayer-action-button">
                                    <span className="material-symbols-outlined">comment</span>
                                    <span>{req.commentCount || 0}</span>
                                </div>
                            </div>
                        </div>
                        {canManageRequest(req) && !req.status && (
                            <div className="item-actions-footer">
                                <button onClick={(e) => { e.stopPropagation(); handleOpenAddModal(req); }} className="edit-button" aria-label="Edit prayer request">
                                    <span className="material-symbols-outlined">edit</span>
                                </button>
                                <button onClick={(e) => { e.stopPropagation(); handleDeleteRequest(req); }} className="delete-button" aria-label="Delete prayer request">
                                    <span className="material-symbols-outlined">delete</span>
                                </button>
                            </div>
                        )}
                    </div>
                ))}
            </div>
            <Fab onClick={() => handleOpenAddModal()} icon="volunteer_activism" aria-label="Add prayer request" />

            {selectedRequest && (
                <PrayerDetailsModal
                    request={selectedRequest}
                    onClose={() => setSelectedRequest(null)}
                    currentUser={currentUser}
                />
            )}
            <PrayerFormModal
                isOpen={isAddModalOpen}
                onClose={handleCloseAddModal}
                onSave={handleSavePrayerRequest}
                request={editingRequest}
            />
        </div>
    );
};


const PrayerFormModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    onSave: (title: string, content: string, imageFile: File | null) => void;
    request: PrayerRequest | null;
}> = ({ isOpen, onClose, onSave, request }) => {
    const [title, setTitle] = useState('');
    const [content, setContent] = useState('');
    const [imageFile, setImageFile] = useState<File | null>(null);

    useEffect(() => {
        if (isOpen) {
            setTitle(request?.title || '');
            setContent(request?.content || '');
            setImageFile(null); // Reset file input
        }
    }, [isOpen, request]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave(title, content, imageFile);
        onClose();
    };
    
    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <form className="modal-form" onSubmit={handleSubmit}>
                <button type="button" className="modal-close-button" onClick={onClose} aria-label="Close">
                     <span className="material-symbols-outlined">close</span>
                </button>
                <h3>{request ? 'अनुरोध सम्पादन गर्नुहोस्' : 'प्रार्थना अनुरोध'}</h3>
                <input
                    type="text"
                    placeholder="शीर्षक"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    required
                />
                <textarea
                    placeholder="हामीले तपाईंको लागि के प्रार्थना गर्नुपर्छ?"
                    rows={5}
                    value={content}
                    onChange={(e) => setContent(e.target.value)}
                    required
                ></textarea>
                <ImageUpload 
                    selectedFile={imageFile} 
                    setSelectedFile={setImageFile} 
                    currentImageUrl={request?.image}
                    label="फोटो थप्नुहोस्।(यदि तपाईं चाहनुहुन्छ भने)" 
                />
                <button type="submit" className="action-button">
                    अनुरोध पठाउनुहोस्।
                </button>
            </form>
        </Modal>
    );
};

const PrayerDetailsModal: React.FC<{
    request: PrayerRequest;
    onClose: () => void;
    currentUser: User;
}> = ({ request, onClose, currentUser }) => {
    const { db } = useFirebase();
    const [newComment, setNewComment] = useState('');
    const [comments, setComments] = useState<Comment[]>([]);
    const [isCommenting, setIsCommenting] = useState(false);

    useEffect(() => {
        if (!db || !request?.id) return;
        const commentsCol = collection(db, "prayerRequests", request.id, "comments");
        const q = query(commentsCol, orderBy("createdAt", "asc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedComments = snapshot.docs.map(doc => ({id: doc.id, ...doc.data() } as Comment));
            setComments(fetchedComments);
        });
        return () => unsubscribe();
    }, [db, request?.id]);


    const handleAddComment = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!db || !newComment.trim() || !request || !currentUser || isCommenting) return;

        setIsCommenting(true);
        try {
            const prayerRequestRef = doc(db, "prayerRequests", request.id);
            const commentsCollectionRef = collection(prayerRequestRef, "comments");
            
            await Promise.all([
                addDoc(commentsCollectionRef, {
                    authorId: currentUser.id,
                    authorName: currentUser.name || "Unknown User",
                    authorAvatar: currentUser.avatar || '',
                    content: newComment,
                    createdAt: serverTimestamp(),
                }),
                updateDoc(prayerRequestRef, {
                    commentCount: increment(1)
                })
            ]);
            
            setNewComment('');
            onClose();
        } catch (error) {
            console.error("Error adding comment: ", error);
            alert("Failed to post comment.");
        } finally {
            setIsCommenting(false);
        }
    };
    
     if (!request) return null;

    return (
        <Modal isOpen={true} onClose={onClose} position="bottom">
            <div>
                 <button type="button" className="modal-close-button" onClick={onClose} aria-label="Close">
                     <span className="material-symbols-outlined">close</span>
                </button>
                <div className="prayer-details-header">
                    <h3>{request.title}</h3>
                </div>
                <p className="prayer-author">By {request.authorName} - {formatDate(request.createdAt)}</p>
                {request.image && <img src={request.image} alt={request.title} style={{ width: '100%', borderRadius: '8px', marginBottom: '16px' }} />}
                <p className="prayer-main-content">{request.content}</p>

                <div className="prayer-comments-section">
                    <h4>Comments ({comments.length})</h4>
                    <div className="prayer-comment-list">
                        {comments.length > 0 ? (
                            comments.map((comment) => (
                                <div key={comment.id} className="comment-item">
                                    <strong>{comment.authorName}</strong>
                                    <p>{comment.content}</p>
                                    <span className="comment-timestamp">{formatRelativeTime(comment.createdAt)}</span>
                                </div>
                            ))
                        ) : (
                            <p className="no-comments">No comments yet.</p>
                        )}
                    </div>
                    <form className="comment-form" onSubmit={handleAddComment}>
                        <input
                            type="text"
                            placeholder="Add a comment..."
                            value={newComment}
                            onChange={(e) => setNewComment(e.target.value)}
                        />
                        <button type="submit" aria-label="Send comment" disabled={isCommenting || !newComment.trim()}>
                            {isCommenting ? <div className="spinner-small"></div> : <span className="material-symbols-outlined">send</span>}
                        </button>
                    </form>
                </div>
            </div>
        </Modal>
    );
};


const ChatListPage: React.FC<{
    currentUser: User;
    usersMap: Map<string, User>;
    onChatSelect: (chatId: string) => void;
    onCreateChat: (participants: User[]) => Promise<string | null>;
}> = ({ currentUser, usersMap, onChatSelect, onCreateChat }) => {
    const { db, storage } = useFirebase();
    const [chats, setChats] = useState<Chat[]>([]);
    const [loading, setLoading] = useState(true);
    const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
    const [chatToDelete, setChatToDelete] = useState<Chat | null>(null);
    const users = Array.from(usersMap.values());
    
    useEffect(() => {
        if (!db || !currentUser?.id) return;
        setLoading(true);
        const q = query(
            collection(db, "chats"), 
            where("participantIds", "array-contains", currentUser.id)
        );
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedChats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Chat));
            // Sort chats on the client-side for robustness against missing fields
            fetchedChats.sort((a, b) => (b.lastActivity?.toMillis() || 0) - (a.lastActivity?.toMillis() || 0));
            setChats(fetchedChats);
            setLoading(false);
        }, (error) => {
            console.error("Error fetching chats: ", error);
            setLoading(false);
        });
        return () => unsubscribe();
    }, [db, currentUser?.id]);


    const getChatDisplayInfo = (chat: Chat, currentUserId: string) => {
        const isGroupChat = chat.participantIds.length > 2;

        if (isGroupChat && chat.name) {
            return { name: chat.name, avatar: '' }; // Use custom group name
        }

        if (isGroupChat) {
            const names = chat.participantIds
                .filter(id => id !== currentUserId)
                .map(id => usersMap.get(id)?.name.split(' ')[0] || '')
                .filter(name => name)
                .slice(0, 2)
                .join(', ');
            return { name: names + (chat.participantIds.length > 3 ? '...' : ''), avatar: '' };
        }
        
        const otherId = chat.participantIds.find(id => id !== currentUserId);
        if (otherId) {
            if (chat.participants && chat.participants[otherId] && chat.participants[otherId].name) {
                return chat.participants[otherId];
            }
            const userFromMap = usersMap.get(otherId);
            if (userFromMap) {
                return { name: userFromMap.name, avatar: userFromMap.avatar };
            }
        }
        
        return { name: "Unknown User", avatar: '' };
    };

    const handleCreateChat = async (selectedUsers: User[]) => {
        const newChatId = await onCreateChat(selectedUsers);
        if (newChatId) {
            onChatSelect(newChatId);
        }
        setIsCreateModalOpen(false);
    };
    
    const handleDeleteChat = async (chat: Chat) => {
        if (!db || !storage) return;
    
        try {
            const messagesQuery = query(collection(db, "chats", chat.id, "messages"));
            const messagesSnapshot = await getDocs(messagesQuery);
            
            const deletePromises: Promise<void>[] = [];
            
            messagesSnapshot.forEach(messageDoc => {
                const message = messageDoc.data() as Message;
                if (message.media) {
                    message.media.forEach(mediaItem => {
                        if (mediaItem.path) {
                            deletePromises.push(deleteObject(ref(storage, mediaItem.path)).catch(err => console.error("Failed to delete media:", err)));
                        }
                    });
                }
                deletePromises.push(deleteDoc(doc(db, "chats", chat.id, "messages", messageDoc.id)));
            });
    
            await Promise.all(deletePromises);
    
            await deleteDoc(doc(db, "chats", chat.id));
    
            setChatToDelete(null);
        } catch (error) {
            console.error("Error deleting chat:", error);
            alert("Failed to delete chat. Please try again.");
            setChatToDelete(null);
        }
    };

    const getLastMessagePreview = (chat: Chat) => {
        if (!chat.lastMessage || !chat.lastMessage.content) return "No messages yet";
        const senderName = chat.lastMessage.senderId === currentUser.id ? "You: " : "";
        
        const content = chat.lastMessage.content;
        // Check for special media previews and return them directly
        if (content === '📷 Photo' || content === '📹 Video' || content === '📷 Media') {
            return `${senderName}${content}`;
        }

        // For regular text messages, just show the content
        return `${senderName}${content}`;
    };

    return (
        <div className="page-content">
            <h2>संगतिहरु</h2>
            <div className="list-container">
                 {loading ? <Loading message="Loading chats..." /> : chats.length > 0 ? (
                    chats.map(chat => {
                        const displayInfo = getChatDisplayInfo(chat, currentUser.id);
                        const isUnread = chat.lastRead && chat.lastMessage && chat.lastMessage.senderId !== currentUser.id && (!chat.lastRead[currentUser.id] || chat.lastRead[currentUser.id] < chat.lastMessage.createdAt);
                        return (
                            <div key={chat.id} className="list-item chat-item">
                                <div className="chat-content-wrapper" onClick={() => onChatSelect(chat.id)}>
                                    <div className="chat-avatar">{getAvatarInitial(displayInfo.name)}</div>
                                    <div className="chat-info">
                                        <span className="chat-name">{displayInfo.name}</span>
                                        <p className="chat-last-message">{getLastMessagePreview(chat)}</p>
                                    </div>
                                    <div className="chat-meta">
                                        <span>{chat.lastActivity ? formatRelativeTime(chat.lastActivity) : ''}</span>
                                        {isUnread && <div className="unread-dot"></div>}
                                    </div>
                                </div>
                                <button className="chat-delete-button" onClick={() => setChatToDelete(chat)} aria-label={`Delete chat with ${displayInfo.name}`}>
                                    <span className="material-symbols-outlined">delete</span>
                                </button>
                            </div>
                        )
                    })
                 ) : (
                    <div className="card" style={{ textAlign: 'center', padding: '32px', color: '#666' }}>
                        <span className="material-symbols-outlined" style={{ fontSize: '48px', color: '#ccc', marginBottom: '16px' }}>chat_bubble</span>
                        <p>No conversations yet.</p>
                        <p style={{ fontSize: 'var(--font-size-sm)', marginTop: '8px' }}>Tap the button below to start a new chat.</p>
                    </div>
                 )}
            </div>
            <Fab onClick={() => setIsCreateModalOpen(true)} icon="groups" aria-label="New chat" />

            <CreateChatModal
                isOpen={isCreateModalOpen}
                onClose={() => setIsCreateModalOpen(false)}
                currentUser={currentUser}
                users={users}
                onCreate={handleCreateChat}
            />

            <Modal isOpen={!!chatToDelete} onClose={() => setChatToDelete(null)}>
                <div className="delete-confirmation">
                    <h3>Delete Conversation?</h3>
                    <p>This will permanently delete this conversation for everyone. This action cannot be undone.</p>
                    <div className="form-actions">
                        <button className="action-button secondary" onClick={() => setChatToDelete(null)}>Cancel</button>
                        <button className="action-button danger" onClick={() => chatToDelete && handleDeleteChat(chatToDelete)}>Delete</button>
                    </div>
                </div>
            </Modal>
        </div>
    );
};

const CreateChatModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    currentUser: User;
    users: User[];
    onCreate: (participants: User[]) => void;
}> = ({ isOpen, onClose, currentUser, users, onCreate }) => {
    const [selectedUsers, setSelectedUsers] = useState<User[]>([]);

    const uniqueUsers = useMemo(() => {
        const userMap = new Map<string, User>();
        users.forEach(user => {
            if (user.email && !userMap.has(user.email)) {
                userMap.set(user.email, user);
            } else if (!user.email) {
                if (!userMap.has(user.id)) {
                    userMap.set(user.id, user);
                }
            }
        });
        return Array.from(userMap.values());
    }, [users]);


    const handleToggleUser = (user: User) => {
        setSelectedUsers(prev =>
            prev.some(u => u.id === user.id)
                ? prev.filter(u => u.id !== user.id)
                : [...prev, user]
        );
    };

    const handleCreate = () => {
        if(selectedUsers.length > 0) {
            onCreate(selectedUsers);
            setSelectedUsers([]);
        }
    };
    
    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <div className="create-chat-modal">
                <h3>Start a conversation</h3>
                <div className="user-list">
                    {uniqueUsers.filter(u => u.id !== currentUser.id).map(user => {
                        const isSelected = selectedUsers.some(su => su.id === user.id);
                        return (
                            <div key={user.id} className={`list-item user-list-item selectable ${isSelected ? 'selected' : ''}`} onClick={() => handleToggleUser(user)}>
                                <div className="chat-avatar">{getAvatarInitial(user.name)}</div>
                                <div className="chat-info">
                                    <span className="chat-name">{user.name}</span>
                                </div>
                                <div className="checkbox">
                                    {isSelected && <span className="material-symbols-outlined">check</span>}
                                </div>
                            </div>
                        )
                    })}
                </div>
                <button
                    className="action-button"
                    style={{ marginTop: '16px' }}
                    onClick={handleCreate}
                    disabled={selectedUsers.length === 0}
                >
                    Start Chat ({selectedUsers.length})
                </button>
            </div>
        </Modal>
    );
};

const RenameChatModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    onSave: (newName: string) => void;
    currentName: string;
}> = ({ isOpen, onClose, onSave, currentName }) => {
    const [name, setName] = useState('');

    useEffect(() => {
        if (isOpen) {
            setName(currentName);
        }
    }, [isOpen, currentName]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (name.trim()) {
            onSave(name.trim());
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <form className="modal-form" onSubmit={handleSubmit}>
                <h3>Rename Group Chat</h3>
                <input
                    type="text"
                    placeholder="Enter new chat name"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    required
                />
                <div className="form-actions">
                    <button type="button" className="action-button secondary" onClick={onClose}>Cancel</button>
                    <button type="submit" className="action-button">Save</button>
                </div>
            </form>
        </Modal>
    );
};

const ConversationPage: React.FC<{
    chatId: string;
    currentUser: User;
    onBack: () => void;
}> = ({ chatId, currentUser, onBack }) => {
    const { db, storage } = useFirebase();
    const { showToast } = useToast();
    const [serverMessages, setServerMessages] = useState<Message[]>([]);
    const [optimisticMessages, setOptimisticMessages] = useState<Message[]>([]);
    const [newMessage, setNewMessage] = useState('');
    const [mediaPreviews, setMediaPreviews] = useState<MediaPreview[]>([]);
    const [currentChat, setCurrentChat] = useState<Chat | null>(null);
    const [loading, setLoading] = useState(true);
    const [deletingMessage, setDeletingMessage] = useState<Message | null>(null);
    const [viewingMedia, setViewingMedia] = useState<{ media: MediaItem[]; startIndex: number } | null>(null);
    const [isRenameModalOpen, setIsRenameModalOpen] = useState(false);

    const messagesEndRef = useRef<HTMLDivElement>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);
    const messageInputRef = useRef<HTMLInputElement>(null);
    
    const sortedMessages = useMemo(() => 
        [...serverMessages, ...optimisticMessages]
            .sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0)),
        [serverMessages, optimisticMessages]
    );

    useEffect(() => {
        if (!db || !chatId) return;
        setLoading(true);
        const chatRef = doc(db, 'chats', chatId);
        const unsubscribeChat = onSnapshot(chatRef, (doc) => {
            if (doc.exists()) {
                setCurrentChat({ id: doc.id, ...doc.data() } as Chat);
            } else { onBack(); }
        });

        const messagesQuery = query(collection(db, "chats", chatId, "messages"), orderBy("createdAt", "asc"));
        const unsubscribeMessages = onSnapshot(messagesQuery, (snapshot) => {
            const newServerMessages = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            } as Message));
            
            setServerMessages(newServerMessages);

            const receivedTempIds = new Set(newServerMessages.map(m => m.tempId).filter(Boolean));
            setOptimisticMessages(prev => prev.filter(om => !receivedTempIds.has(om.tempId)));

            setLoading(false);
        });

        updateDoc(chatRef, { [`lastRead.${currentUser.id}`]: Timestamp.now() }).catch(err => console.error("Error updating lastRead:", err));
        
        return () => { unsubscribeChat(); unsubscribeMessages(); }
    }, [db, chatId, onBack, currentUser.id]);


    useEffect(() => {
        if (!loading) { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }
    }, [sortedMessages, loading]);

    const handleSendMessage = useCallback(async () => {
        const textContent = newMessage.trim();
        const mediaFiles = [...mediaPreviews];
        if (!db || !storage || !currentChat || !currentUser || (!textContent && mediaFiles.length === 0)) return;
    
        setNewMessage('');
        setMediaPreviews([]);
        messageInputRef.current?.focus();
    
        const tempId = crypto.randomUUID();
    
        const optimisticMessage: Message = {
            id: tempId, tempId, senderId: currentUser.id, createdAt: Timestamp.now(), status: 'uploading',
            ...(textContent && { content: textContent }),
            ...(mediaFiles.length > 0 && {
                media: mediaFiles.map(p => ({ url: p.url, type: p.type })),
            }),
        };
        setOptimisticMessages(prev => [...prev, optimisticMessage]);
    
        try {
            const uploadMedia = async (preview: MediaPreview): Promise<MediaItem> => {
                const fileToUpload = preview.type === 'image' ? await compressImage(preview.file) : preview.file;
                const filePath = `chat_media/${currentChat.id}/${Date.now()}_${fileToUpload.name}`;
                const mediaRef = ref(storage, filePath);
                
                // Use the simpler uploadBytes for more stability
                await uploadBytes(mediaRef, fileToUpload);
                
                const url = await getDownloadURL(mediaRef);
                return { url, type: preview.type, path: filePath };
            };
    
            const uploadPromises = mediaFiles.map(uploadMedia);
            const uploadedMedia = await Promise.all(uploadPromises);
            
            const messagePayload = {
                senderId: currentUser.id, 
                createdAt: serverTimestamp(),
                tempId,
                ...(textContent && { content: textContent }),
                ...(uploadedMedia.length > 0 && { media: uploadedMedia }),
            };

            await addDoc(collection(db, "chats", currentChat.id, "messages"), messagePayload);
            
            let lastMessageContent = textContent;
            if (!textContent && uploadedMedia.length > 0) {
                 lastMessageContent = uploadedMedia.length > 1 ? '📷 Media' : (uploadedMedia[0].type === 'video' ? '📹 Video' : '📷 Photo');
            }
             
            await updateDoc(doc(db, "chats", currentChat.id), {
                 lastMessage: { content: lastMessageContent, senderId: currentUser.id, createdAt: serverTimestamp() },
                 lastActivity: serverTimestamp(),
                 [`lastRead.${currentUser.id}`]: serverTimestamp()
            });

        } catch (error: any) {
            console.error("❌ Failed to send message. Error Code:", error.code);
            console.error("❌ Failed to send message. Error Message:", error.message);
            console.error("❌ Full Error:", error);
            showToast("Error", "Failed to send message.");
            setOptimisticMessages(prev => prev.map(m => m.tempId === tempId ? { ...m, status: 'failed' } : m));
        }
    }, [newMessage, mediaPreviews, db, storage, currentChat, currentUser, showToast]);
    
    const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files) {
            const files = Array.from(e.target.files);
            const newPreviews: MediaPreview[] = files.map(file => ({
                id: crypto.randomUUID(),
                url: URL.createObjectURL(file),
                file,
                type: file.type.startsWith('image/') ? 'image' : 'video'
            }));
            setMediaPreviews(prev => [...prev, ...newPreviews]);
            if (fileInputRef.current) fileInputRef.current.value = "";
        }
    };
    
    const handleDeleteMessage = async (messageToDelete: Message) => {
        if (!db || !storage || !messageToDelete || !currentChat) return;
        setDeletingMessage(null);

        // Optimistically remove from UI
        if (messageToDelete.status) { // It's an optimistic message
             setOptimisticMessages(prev => prev.filter(m => m.tempId !== messageToDelete.tempId));
        } else {
             setServerMessages(prev => prev.filter(m => m.id !== messageToDelete.id));
        }


        if (messageToDelete.tempId && messageToDelete.status !== 'failed') {
            // It was an uploading message that hasn't been sent, just remove it locally.
            return;
        }

        try {
            if (messageToDelete.media && messageToDelete.media.length > 0) {
                 await Promise.all(messageToDelete.media.map(item => {
                    if (item.path) {
                        return deleteObject(ref(storage, item.path))
                          .catch(err => console.error(`Failed to delete media ${item.path}:`, err));
                    }
                    return Promise.resolve();
                }));
            }
            if (!messageToDelete.tempId) { // Only delete from DB if it's not a temp message
                await deleteDoc(doc(db, "chats", currentChat.id, "messages", messageToDelete.id));
            }
        } catch (error) {
            console.error("Error deleting message:", error);
            alert("Failed to delete message.");
            // Re-add message to UI if delete fails. This is complex, so for now we leave it removed.
            // A more robust solution would involve a state rollback.
        }
    };
    
    const handleRenameChat = async (newName: string) => {
        if (!db || !currentChat || !newName.trim()) return;
        try {
            await updateDoc(doc(db, "chats", currentChat.id), {
                name: newName.trim()
            });
            setIsRenameModalOpen(false);
        } catch (error) {
            console.error("Error renaming chat:", error);
            alert("Failed to rename chat.");
        }
    };

    const getChatTitle = () => {
        if (currentChat?.name) return currentChat.name;
        if (!currentChat?.participants) return "Conversation";
        if (currentChat.participantIds.length > 2) {
             return currentChat.participantIds
                .filter(id => id !== currentUser.id)
                .map(id => currentChat.participants[id]?.name.split(' ')[0] || '')
                .join(', ');
        }
        const otherId = currentChat.participantIds.find(id => id !== currentUser.id);
        return otherId ? currentChat.participants[otherId]?.name : "Chat";
    };
    
    return (
        <div className="conversation-page">
            <header className="conversation-header">
                <button onClick={onBack} className="back-button" aria-label="Back to chats">
                    <span className="material-symbols-outlined">arrow_back</span>
                </button>
                <h3>{getChatTitle()}</h3>
                {(currentChat?.participantIds.length ?? 0) > 2 ? (
                    <button onClick={() => setIsRenameModalOpen(true)} className="header-action-button" aria-label="Rename chat">
                        <span className="material-symbols-outlined">edit</span>
                    </button>
                ) : (
                    <div className="header-action-button" style={{ visibility: 'hidden' }}></div>
                )}
            </header>
            <div className="message-list">
                {loading ? <Loading message="Loading messages..." /> : (
                    <>
                        {sortedMessages.map(msg => (
                            <MessageBubble 
                                key={msg.tempId || msg.id} 
                                message={msg} 
                                isSent={msg.senderId === currentUser.id} 
                                onMediaClick={(index) => msg.media && setViewingMedia({ media: msg.media, startIndex: index })}
                                onLongPress={() => setDeletingMessage(msg)}
                            />
                        ))}
                        <div ref={messagesEndRef} />
                    </>
                )}
            </div>
            <div className="message-input-container">
                {mediaPreviews.length > 0 && (
                    <div className="media-preview-container">
                        {mediaPreviews.map((p) => (
                            <div key={p.id} className="media-preview-item">
                                {p.type === 'image' ? <img src={p.url} alt="preview" /> : <video src={p.url} />}
                                <button onClick={() => setMediaPreviews(prev => prev.filter(item => item.id !== p.id))}>
                                    <span className="material-symbols-outlined">close</span>
                                </button>
                            </div>
                        ))}
                    </div>
                )}
                <div className="message-input-row">
                    <input type="file" ref={fileInputRef} onChange={handleFileSelect} style={{display: 'none'}} multiple accept="image/*,video/*" disabled={loading} />
                    <button 
                        className="input-action-button" 
                        onMouseDown={(e) => e.preventDefault()}
                        onClick={() => fileInputRef.current?.click()}
                        aria-label="Attach file" 
                        disabled={loading}
                    >
                        <span className="material-symbols-outlined">add_photo_alternate</span>
                    </button>
                    <input
                        ref={messageInputRef}
                        type="text" placeholder="Type a message..." value={newMessage}
                        onChange={(e) => setNewMessage(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                        disabled={loading}
                    />
                    <button className="send-button" onClick={handleSendMessage} disabled={loading || (!newMessage.trim() && mediaPreviews.length === 0)}>
                        <span className="material-symbols-outlined">send</span>
                    </button>
                </div>
            </div>
            {deletingMessage && (
                <Modal isOpen={true} onClose={() => setDeletingMessage(null)}>
                    <div className="delete-confirmation">
                        <p>Are you sure you want to delete this message for everyone?</p>
                        <div className="form-actions">
                            <button className="action-button secondary" onClick={() => setDeletingMessage(null)}>Cancel</button>
                            <button className="action-button danger" onClick={() => handleDeleteMessage(deletingMessage)}>Delete</button>
                        </div>
                    </div>
                </Modal>
            )}
            {viewingMedia && (
                <MediaViewer
                    mediaItems={viewingMedia.media}
                    startIndex={viewingMedia.startIndex}
                    onClose={() => setViewingMedia(null)}
                />
            )}
             {isRenameModalOpen && (
                <RenameChatModal
                    isOpen={isRenameModalOpen}
                    onClose={() => setIsRenameModalOpen(false)}
                    onSave={handleRenameChat}
                    currentName={getChatTitle()}
                />
            )}
        </div>
    );
};

const UploadProgressCircle: React.FC<{ progress: number }> = ({ progress }) => {
    const radius = 18;
    const circumference = 2 * Math.PI * radius;
    const offset = circumference - (progress / 100) * circumference;

    return (
        <svg className="upload-progress-circle">
            <circle className="progress-background" cx="20" cy="20" r={radius} />
            <circle
                className="progress-bar"
                cx="20" cy="20" r={radius}
                strokeDasharray={circumference}
                strokeDashoffset={offset}
            />
        </svg>
    );
};

const MessageBubble: React.FC<{
    message: Message;
    isSent: boolean;
    onMediaClick: (index: number) => void;
    onLongPress: () => void;
}> = ({ message, isSent, onMediaClick, onLongPress }) => {
    const timerRef = useRef<number | null>(null);

    const handlePointerDown = () => {
        if (isSent) { // Only sent messages can be deleted
            timerRef.current = window.setTimeout(() => {
                onLongPress();
                timerRef.current = null; // Prevent clear on pointer up
            }, 700); // 700ms threshold for long press
        }
    };

    const handlePointerUp = () => {
        if (timerRef.current) {
            clearTimeout(timerRef.current);
            timerRef.current = null;
        }
    };
    
    const handleContextMenu = (e: React.MouseEvent) => {
         if (isSent) {
            e.preventDefault();
            onLongPress();
         }
    };

    return (
        <div className={`message-container ${isSent ? 'sent' : 'received'}`}>
            <div 
                className={`message-bubble ${message.media ? 'has-media' : ''}`}
                onMouseDown={handlePointerDown}
                onMouseUp={handlePointerUp}
                onTouchStart={handlePointerDown}
                onTouchEnd={handlePointerUp}
                onContextMenu={handleContextMenu}
            >
                {message.media && message.media.length > 0 && (
                    <MediaGrid media={message.media} onMediaClick={onMediaClick} />
                )}
                {message.content && <p className="message-content">{message.content}</p>}
                <div className="message-footer">
                    <span className="message-timestamp">{formatTime(message.createdAt)}</span>
                    {message.status === 'uploading' && <div className="spinner-small" style={{borderColor: '#999', borderTopColor: '#666'}}></div>}
                    {message.status === 'failed' && <span className="material-symbols-outlined message-failed-indicator">error</span>}
                </div>
            </div>
        </div>
    );
};

const MediaGrid: React.FC<{ media: MediaItem[], onMediaClick: (index: number) => void }> = ({ media, onMediaClick }) => {
    const count = media.length;
    const displayMedia = count > 4 ? media.slice(0, 4) : media;

    return (
        <div className={`media-grid count-${Math.min(count, 4)}`}>
            {displayMedia.map((item, index) => (
                <div key={index} className="media-grid-item" onClick={(e) => {
                    e.stopPropagation(); // Prevents the parent bubble's long press logic from interfering
                    onMediaClick(index);
                }}>
                    {item.type === 'image' ? <img src={item.url} alt="media content" /> : <video src={item.url} />}
                    {item.type === 'video' && (
                        <div className="video-play-icon">
                            <span className="material-symbols-outlined">play_circle</span>
                        </div>
                    )}
                    {count > 4 && index === 3 && (
                        <div className="more-overlay">+{count - 4}</div>
                    )}
                </div>
            ))}
        </div>
    );
};

const MediaViewer: React.FC<{
    mediaItems: MediaItem[];
    startIndex: number;
    onClose: () => void;
}> = ({ mediaItems, startIndex, onClose }) => {
    const [currentIndex, setCurrentIndex] = useState(startIndex);
    const currentItem = mediaItems[currentIndex];

    const goToPrev = (e: React.MouseEvent) => {
        e.stopPropagation();
        setCurrentIndex(prev => (prev === 0 ? mediaItems.length - 1 : prev - 1));
    }
    const goToNext = (e: React.MouseEvent) => {
        e.stopPropagation();
        setCurrentIndex(prev => (prev === mediaItems.length - 1 ? 0 : prev + 1));
    }

    return createPortal(
        <div className="media-viewer-backdrop" onClick={onClose}>
            <div className="media-viewer-content" onClick={e => e.stopPropagation()}>
                {currentItem.type === 'image' 
                    ? <img src={currentItem.url} alt="media" />
                    : <video src={currentItem.url} controls autoPlay />
                }
            </div>
            <button className="media-viewer-close" onClick={onClose}><span className="material-symbols-outlined">close</span></button>
            {mediaItems.length > 1 && (
                <>
                    <button className="media-viewer-nav prev" onClick={goToPrev}><span className="material-symbols-outlined">arrow_back_ios</span></button>
                    <button className="media-viewer-nav next" onClick={goToNext}><span className="material-symbols-outlined">arrow_forward_ios</span></button>
                </>
            )}
        </div>,
        document.body
    );
};

// --- User Management (Admin) ---
const ManageUsersModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    users: User[];
}> = ({ isOpen, onClose, users }) => {
    const { db } = useFirebase();

    const handleRoleChange = async (userId: string, role: UserRole, isChecked: boolean) => {
        if (!db) return;
        const userRef = doc(db, "users", userId);
        await updateDoc(userRef, {
            roles: isChecked ? arrayUnion(role) : arrayRemove(role)
        });
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <div className="manage-users-modal">
                <h3>Manage User Roles</h3>
                <div className="user-list user-role-list">
                    {users.map(user => (
                        <div key={user.id} className="card user-role-item">
                            <p className="user-name">{user.name}</p>
                            <p className="user-email">{user.email}</p>
                            <div className="role-checkboxes">
                                {(['admin', 'news_contributor', 'podcast_contributor'] as UserRole[]).map(role => (
                                    <label key={role}>
                                        <input
                                            type="checkbox"
                                            checked={user.roles.includes(role)}
                                            onChange={(e) => handleRoleChange(user.id, role, e.target.checked)}
                                        />
                                        {role.replace('_', ' ')}
                                    </label>
                                ))}
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        </Modal>
    );
};


// --- Notifications ---
const NotificationPanel: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    notifications: Notification[];
}> = ({ isOpen, onClose, notifications }) => {
    return createPortal(
        <>
            <div className={`notification-backdrop ${isOpen ? 'open' : ''}`} onClick={onClose}></div>
            <div className={`notification-panel ${isOpen ? 'open' : ''}`}>
                <header className="notification-header">
                    <h3>Notifications</h3>
                    <button className="panel-close-button" onClick={onClose} aria-label="Close notifications">
                        <span className="material-symbols-outlined">close</span>
                    </button>
                </header>
                <div className="notification-list">
                    {notifications.length > 0 ? (
                        notifications.map(notif => (
                            <div key={notif.id} className="notification-item">
                                <span className="material-symbols-outlined notification-icon">{notif.icon}</span>
                                <div>
                                    <p>{notif.message}</p>
                                    <p className="notification-timestamp">{notif.timestamp}</p>
                                </div>
                            </div>
                        ))
                    ) : (
                         <div className="no-notifications">
                            <p>You have no new notifications.</p>
                        </div>
                    )}
                </div>
            </div>
        </>,
        document.body
    );
};

// --- Installation Guide Page ---
const InstallationGuidePage: React.FC = () => {
    const [os, setOs] = useState<'ios' | 'android' | 'other' | null>(null);

    useEffect(() => {
        const userAgent = navigator.userAgent || navigator.vendor || (window as any).opera;
        if (/iPad|iPhone|iPod/.test(userAgent) && !(window as any).MSStream) {
            setOs('ios');
        } else if (/android/i.test(userAgent)) {
            setOs('android');
        } else {
            setOs('other');
        }
    }, []);

    const IosInstructions = () => (
        <div className="instruction-steps">
            <h3>iPhone/iPad에 앱 설치하기</h3>
            <div className="step">
                <p>1. 화면 하단의 '공유' 아이콘을 누르세요.</p>
                <span className="material-symbols-outlined instruction-icon">ios_share</span>
            </div>
            <div className="step">
                <p>2. '홈 화면에 추가'를 찾아 누르세요.</p>
                <span className="material-symbols-outlined instruction-icon">add_box</span>
            </div>
            <div className="step">
                <p>3. 오른쪽 상단의 '추가'를 누르면 설치가 완료됩니다.</p>
                 <span className="material-symbols-outlined instruction-icon">add</span>
            </div>
        </div>
    );

    const AndroidInstructions = () => (
         <div className="instruction-steps">
            <h3>Android에 앱 설치하기</h3>
            <div className="step">
                <p>1. 오른쪽 상단의 점 3개 메뉴를 누르세요.</p>
                <span className="material-symbols-outlined instruction-icon">more_vert</span>
            </div>
            <div className="step">
                <p>2. '앱 설치' 또는 '홈 화면에 추가'를 누르세요.</p>
                <span className="material-symbols-outlined instruction-icon">install_mobile</span>
            </div>
            <div className="step">
                <p>3. '설치'를 누르면 바로 설치가 완료됩니다.</p>
                <span className="material-symbols-outlined instruction-icon">download</span>
            </div>
        </div>
    );
    
    const OtherInstructions = () => (
         <div className="instruction-steps">
            <h3>앱 설치하기</h3>
            <p><strong>Chrome/Edge 브라우저:</strong> 주소창 오른쪽의 컴퓨터 모양 아이콘을 클릭하여 설치하세요.</p>
            <p><strong>모바일 기기:</strong> 브라우저 메뉴에서 '홈 화면에 추가' 또는 '앱 설치' 옵션을 찾아보세요.</p>
        </div>
    );

    return (
        <div className="page-content install-guide-container">
            <img src={CHURCH.logo} alt="Church Logo" className="install-guide-logo" />
            <h2>{CHURCH.name} 앱</h2>
            <p className="install-guide-subtitle">앱을 휴대폰에 설치하여 더 쉽게 접속하세요.</p>
            <div className="card">
                {os === 'ios' && <IosInstructions />}
                {os === 'android' && <AndroidInstructions />}
                {os === 'other' && <OtherInstructions />}
                {!os && <Loading message="기기 정보를 확인 중입니다..." />}
            </div>
            <a href="/" className="action-button install-guide-button">
                앱으로 바로가기
                <span className="material-symbols-outlined">arrow_forward</span>
            </a>
        </div>
    );
};


// --- Main App Component ---
const App: React.FC = () => {
    const firebaseServices = useFirebase();
    const { auth, db } = firebaseServices;
    const { showToast } = useToast();
    
    const [currentUser, setCurrentUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);
    const [activePage, setActivePage] = useState<'worship' | 'bible' | 'news' | 'podcast' | 'prayer' | 'chat'>('news');
    const [currentChatId, setCurrentChatId] = useState<string | null>(null);
    const [isManageUsersOpen, setIsManageUsersOpen] = useState(false);
    const [isNotificationPanelOpen, setIsNotificationPanelOpen] = useState(false);
    
    // Data states
    const [worshipService, setWorshipService] = useState<WorshipService | null>(null);
    const [pastServices, setPastServices] = useState<PastWorshipService[]>([]);
    const [news, setNews] = useState<NewsItem[]>([]);
    const [podcasts, setPodcasts] = useState<Podcast[]>([]);
    const [prayerRequests, setPrayerRequests] = useState<PrayerRequest[]>([]);
    const [users, setUsers] = useState<User[]>([]);
    const [notifications, setNotifications] = useState<Notification[]>([]);
    const [hasUnreadNotifications, setHasUnreadNotifications] = useState(false);
    const [notificationPermissionStatus, setNotificationPermissionStatus] = useState<NotificationPermission>('default');

    const deepLinkProcessed = useRef(false);

    // Simple routing for the installation page
    if (window.location.pathname === '/install') {
        return <InstallationGuidePage />;
    }

    const isConversationOpen = !!currentChatId;

    const usersMap = useMemo(() => {
        const map = new Map<string, User>();
        users.forEach(user => map.set(user.id, user));
        return map;
    }, [users]);

    const pageConfig = {
        news: { label: 'सुचना', icon: 'feed' },
        worship: { label: 'आरधना', icon: 'church' },
        podcast: { label: 'Podcast', icon: 'podcasts' },
        bible: { label: 'बाइबल', icon: 'menu_book' },
        chat: { label: 'संगतिहरु', icon: 'groups' },
        prayer: { label: 'प्रार्थना', icon: 'volunteer_activism' },
    };
    
    const navOrder: (keyof typeof pageConfig)[] = ['news', 'worship', 'podcast', 'bible', 'chat', 'prayer'];

    // --- Authentication ---
    useEffect(() => {
        if (!auth || !db) return;
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            if (user) { 
                const userDocRef = doc(db, "users", user.uid);
                const userDocSnap = await getDoc(userDocRef);

                let rolesToAdd: UserRole[] = [];
                const existingRoles: UserRole[] = userDocSnap.exists() ? (userDocSnap.data().roles || []) : [];

                if (user.email === 'davidrai441@gmail.com' && !existingRoles.includes('admin')) {
                    rolesToAdd.push('admin');
                } else if (user.email === 'koiralacm@gmail.com') {
                    if (!existingRoles.includes('news_contributor')) rolesToAdd.push('news_contributor');
                    if (!existingRoles.includes('podcast_contributor')) rolesToAdd.push('podcast_contributor');
                }

                if (userDocSnap.exists()) {
                    if (rolesToAdd.length > 0) {
                        await updateDoc(userDocRef, { roles: arrayUnion(...rolesToAdd) });
                    }
                    
                    const userData = userDocSnap.data();
                    const finalRoles = [...new Set([...existingRoles, ...rolesToAdd])];
                    
                    if (!user.displayName && userData.name) {
                        await updateProfile(user, { displayName: userData.name });
                    }
                     if (!user.photoURL && userData.avatar) {
                        await updateProfile(user, { photoURL: userData.avatar });
                    }
                    
                    setCurrentUser({ 
                        id: user.uid, 
                        name: user.displayName || userData.name || '',
                        email: user.email || userData.email || '',
                        avatar: user.photoURL || userData.avatar || '',
                        roles: finalRoles
                    } as User);

                } else {
                    const baseRoles: UserRole[] = ['member'];
                    const finalRoles = [...new Set([...baseRoles, ...rolesToAdd])];
                    
                    const newUser: Omit<User, 'id'> = {
                        name: user.displayName || 'New User',
                        email: user.email || '',
                        avatar: user.photoURL || '',
                        roles: finalRoles,
                    };
                    await setDoc(userDocRef, newUser);
                    setCurrentUser({ id: user.uid, ...newUser } as User);
                }
            } else {
                setCurrentUser(null);
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, [auth, db]);


    // --- Data Fetching (Hardened against missing indexes) ---
    useEffect(() => {
        if (!db || !currentUser) return;
        
        // Listeners
        const unsubWorship = onSnapshot(query(collection(db, "worshipServices"), where("isLive", "==", true), limit(1)), (snapshot) => {
            setWorshipService(snapshot.empty ? null : { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as WorshipService);
        });

        const unsubPastWorship = onSnapshot(query(collection(db, "pastWorshipServices"), orderBy("createdAt", "desc")), (snapshot) => {
            const services = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as PastWorshipService));
            setPastServices(services);
        });

        const unsubNews = onSnapshot(query(collection(db, "news"), orderBy("createdAt", "desc")), (snapshot) => {
            const items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as NewsItem));
            setNews(items);
        });

        const unsubPodcasts = onSnapshot(query(collection(db, "podcasts"), orderBy("createdAt", "desc")), (snapshot) => {
            const podcasts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Podcast));
            setPodcasts(podcasts);
        });

        const unsubPrayer = onSnapshot(query(collection(db, "prayerRequests"), orderBy("createdAt", "desc")), (snapshot) => {
            const requests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as PrayerRequest));
            setPrayerRequests(requests);
        });

        const unsubUsers = onSnapshot(query(collection(db, "users")), (snapshot) => {
            const users = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as User));
            users.sort((a, b) => a.name.localeCompare(b.name));
            setUsers(users);
        });

        return () => {
            unsubWorship();
            unsubPastWorship();
            unsubNews();
            unsubPodcasts();
            unsubPrayer();
            unsubUsers();
        };

    }, [db, currentUser]);
    
    // --- Deep linking from notifications ---
    useEffect(() => {
        if (deepLinkProcessed.current) return;

        const params = new URLSearchParams(window.location.search);
        const page = params.get('page');
        const chatIdParam = params.get('chatId');

        const handleDeepLink = () => {
            if (page === 'chat' && chatIdParam) {
                setActivePage('chat');
                setCurrentChatId(chatIdParam);
                deepLinkProcessed.current = true;
                window.history.replaceState({}, document.title, window.location.pathname);
            } else if (page && navOrder.includes(page as any)) {
                setActivePage(page as any);
                deepLinkProcessed.current = true;
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        };
        
        setTimeout(handleDeepLink, 100);

    }, []);

    // --- FCM/Push Notifications ---
    const requestPermissionAndToken = useCallback(async () => {
        if (!firebaseServices.messaging || !currentUser || !db) return;
        const { messaging } = firebaseServices;
    
        try {
            let permission = Notification.permission;
            if (permission === 'default') {
                permission = await Notification.requestPermission();
                setNotificationPermissionStatus(permission); // Update UI based on user's choice
            }
    
            if (permission === 'granted') {
                const currentToken = await getToken(messaging, { vapidKey: import.meta.env.VITE_FIREBASE_VAPID_KEY });
                if (currentToken) {
                    console.log('✅ FCM Token generated:', currentToken);
                    const userRef = doc(db, "users", currentUser.id);
                    const userDoc = await getDoc(userRef);
                    const userTokens = userDoc.data()?.fcmTokens || [];
                    if (!userTokens.includes(currentToken)) {
                        await updateDoc(userRef, {
                            fcmTokens: arrayUnion(currentToken)
                        });
                    }
                } else {
                    console.log('No registration token available. Request permission to generate one.');
                }
            } else {
                 console.log('Notification permission not granted.');
                 if (permission === 'denied') {
                     showToast("Notifications Blocked", "You can enable notifications in your browser settings later.");
                 }
            }
        } catch (err: any) {
            console.error('❌ Failed to get token. Error Code:', err.code);
            console.error('❌ Failed to get token. Error Message:', err.message);
            console.error('❌ Full Error:', err);
        }
    }, [firebaseServices, currentUser, db, showToast]);

    // Effect to check permission status and get token on load
    useEffect(() => {
        if (currentUser) {
            setNotificationPermissionStatus(Notification.permission);
            // Re-request token if permission is already granted, to ensure it's up to date
            if (Notification.permission === 'granted') {
                requestPermissionAndToken();
            }
        }
    }, [currentUser, requestPermissionAndToken]);
    
    // Effect for handling incoming messages
    useEffect(() => {
        if (!firebaseServices.messaging || !currentUser) return;
        const { messaging } = firebaseServices;
    
        const unsubscribeOnMessage = onMessage(messaging, (payload) => {
             const data = payload.notification;
             const customData = payload.data;
             const fromChatId = customData?.chatId;
    
             if (fromChatId && fromChatId === currentChatId) {
                // If user is already in the chat, don't show a toast.
                return;
             }
             
             showToast(
                data?.title || 'New Message',
                data?.body || 'You have a new message.',
                () => {
                    const urlString = customData?.url;
                    if (urlString) {
                        const url = new URL(urlString);
                        const page = url.searchParams.get('page');
                        const chatId = url.searchParams.get('chatId');
    
                        if (page === 'chat' && chatId) {
                             setActivePage('chat');
                             setCurrentChatId(chatId);
                        } else if (page && navOrder.includes(page as any)) {
                            setActivePage(page as any);
                        }
                    }
                }
             );
             setHasUnreadNotifications(true);
        });
    
        return () => unsubscribeOnMessage();
    }, [firebaseServices.messaging, currentUser, db, showToast, currentChatId]);


    const handleCreateChat = async (selectedUsers: User[]): Promise<string | null> => {
        if (!db || !currentUser) return null;
        
        const allParticipants = [currentUser, ...selectedUsers];
        const allParticipantIds = allParticipants.map(p => p.id).sort();

        // Check if a chat with these exact participants already exists to avoid duplicates (works for 1-on-1 and groups).
        const q = query(collection(db, "chats"), where("participantIds", "==", allParticipantIds));
        const existingChats = await getDocs(q);
        if (!existingChats.empty) {
           return existingChats.docs[0].id; // Return existing chat ID
        }
       
        const participantsData = allParticipants.reduce((acc, user) => {
            acc[user.id] = { name: user.name, avatar: user.avatar };
            return acc;
        }, {} as { [key: string]: { name: string, avatar: string }});

        try {
             const newChatRef = await addDoc(collection(db, "chats"), {
                participantIds: allParticipantIds,
                participants: participantsData,
                lastActivity: serverTimestamp(),
            });
            return newChatRef.id;
        } catch (error) {
            console.error("Error creating chat:", error);
            return null;
        }
    };
    
    const handleChatSelect = (chatId: string) => {
        setActivePage('chat'); // Ensure the underlying page is 'chat'
        setCurrentChatId(chatId);
    };

    const handleBackFromConversation = useCallback(() => {
        setCurrentChatId(null);
    }, []);

    if (firebaseServices.firebaseError) {
        return <ErrorFallback error={new Error(firebaseServices.firebaseError)} />;
    }
    if (loading) {
        return <SplashScreen />;
    }
    if (!currentUser) {
        return <LoginPage />;
    }
    
    const isAdmin = currentUser.roles.includes('admin');

    const renderPage = () => {
        if (isConversationOpen) {
            return (
                <ConversationPage
                    key={currentChatId}
                    chatId={currentChatId!}
                    currentUser={currentUser}
                    onBack={handleBackFromConversation}
                />
            );
        }
    
        switch (activePage) {
            case 'news':
                return <NewsPage currentUser={currentUser} news={news} setNews={setNews} />;
            case 'worship':
                return <WorshipPage currentUser={currentUser} liveService={worshipService} pastServices={pastServices} />;
            case 'podcast':
                return <PodcastsPage currentUser={currentUser} podcasts={podcasts} setPodcasts={setPodcasts} />;
            case 'bible':
                return <BiblePage />;
            case 'chat':
                return (
                    <ChatListPage
                        currentUser={currentUser}
                        usersMap={usersMap}
                        onChatSelect={handleChatSelect}
                        onCreateChat={handleCreateChat}
                    />
                );
            case 'prayer':
                return <PrayerPage currentUser={currentUser} requests={prayerRequests} setRequests={setPrayerRequests} />;
            default:
                return <NewsPage currentUser={currentUser} news={news} setNews={setNews} />;
        }
    };

    return (
        <div className="app-container">
            {notificationPermissionStatus === 'denied' && !isConversationOpen && (
                <div className="notification-permission-banner denied">
                    <span className="material-symbols-outlined">notifications_off</span>
                    <p>알림이 차단되었습니다. 메시지 및 업데이트를 받으려면 브라우저 설정에서 이 사이트의 알림을 허용해 주세요.</p>
                </div>
            )}

            {notificationPermissionStatus === 'default' && !isConversationOpen && (
                <div className="notification-permission-banner request">
                    <span className="material-symbols-outlined">notifications</span>
                    <p>알림을 활성화하여 새로운 메시지와 업데이트를 받으세요.</p>
                    <button onClick={requestPermissionAndToken}>활성화</button>
                </div>
            )}

            {!isConversationOpen && (
                <header className="app-header">
                    <div className="header-content">
                        <img src={CHURCH.logo} alt="Church Logo" className="header-logo" />
                        <h1>{CHURCH.name}</h1>
                    </div>
                    <div className="header-actions">
                        <button className="header-button" onClick={() => {
                            setIsNotificationPanelOpen(true);
                            setHasUnreadNotifications(false);
                        }}>
                            <span className="material-symbols-outlined">notifications</span>
                            {hasUnreadNotifications && <div className="notification-dot"></div>}
                        </button>
                         {isAdmin && (
                            <button className="header-button" onClick={() => setIsManageUsersOpen(true)}>
                                <span className="material-symbols-outlined">manage_accounts</span>
                            </button>
                         )}
                        <button className="header-button" onClick={() => auth && signOut(auth)}>
                            <span className="material-symbols-outlined">logout</span>
                        </button>
                    </div>
                </header>
            )}

            <main className={`main-content ${isConversationOpen ? 'full-height' : ''}`}>
                 {renderPage()}
            </main>

            {!isConversationOpen && (
                <nav className="bottom-nav">
                    {navOrder.map(page => (
                        <button key={page} className={`nav-item ${activePage === page ? 'active' : ''}`} onClick={() => setActivePage(page)}>
                            <span className="material-symbols-outlined">
                                {pageConfig[page].icon}
                            </span>
                            <span>{pageConfig[page].label}</span>
                        </button>
                    ))}
                </nav>
            )}
            
            <ManageUsersModal
                isOpen={isManageUsersOpen}
                onClose={() => setIsManageUsersOpen(false)}
                users={users}
            />
            
            <NotificationPanel 
                isOpen={isNotificationPanelOpen}
                onClose={() => setIsNotificationPanelOpen(false)}
                notifications={notifications}
            />
        </div>
    );
};


// --- Error Boundary ---
interface ErrorBoundaryProps {
  children: React.ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  state: ErrorBoundaryState = { hasError: false, error: null };

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error: error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError && this.state.error) {
      return <ErrorFallback error={this.state.error} />;
    }
    return this.props.children;
  }
}



// --- App Root ---
const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(
    <React.StrictMode>
        <ErrorBoundary>
            <FirebaseContext.Provider value={initializeFirebaseServices()}>
                <ToastProvider>
                   <App />
                </ToastProvider>
            </FirebaseContext.Provider>
        </ErrorBoundary>
    </React.StrictMode>
);

// --- Service Worker Registration ---
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js').then(registration => {
      console.log('SW registration successful with scope: ', registration.scope);
      registration.addEventListener('updatefound', () => {
        // A new service worker is installing.
        console.log('A new service worker is being installed.');
      });
    }).catch(registrationError => {
      console.error('SW registration failed: ', registrationError);
    });
    
    let refreshing: boolean;
    navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (refreshing) return;
        console.log('New service worker has taken control. Reloading page.');
        window.location.reload();
        refreshing = true;
    });
  });
}