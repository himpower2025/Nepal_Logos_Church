import React, { useState, useEffect, useRef, useCallback, createContext, useContext, useMemo } from 'react';
import ReactDOM from 'react-dom/client';
import { createPortal } from 'react-dom';
import './index.css';
import { initializeFirebaseServices, FirebaseServices } from './firebase';
import { 
    createUserWithEmailAndPassword, 
    signInWithEmailAndPassword, 
    onAuthStateChanged,
    signOut,
    updateProfile,
    GoogleAuthProvider,
    signInWithPopup,
    User as FirebaseAuthUser,
} from "firebase/auth";
import { 
    collection, 
    addDoc, 
    onSnapshot, 
    query, 
    orderBy, 
    doc, 
    updateDoc, 
    serverTimestamp,
    getDoc,
    setDoc,
    arrayUnion,
    Timestamp,
    where,
    arrayRemove,
    deleteDoc,
    getDocs,
    limit,
    increment
} from "firebase/firestore";
import { ref, getDownloadURL, uploadBytes, deleteObject } from "firebase/storage";
import { getToken, onMessage } from "firebase/messaging";


// --- Firebase Context for safe dependency injection ---
const FirebaseContext = createContext<FirebaseServices | null>(null);
export const useFirebase = () => {
    const context = useContext(FirebaseContext);
    if (!context) {
        throw new Error("useFirebase must be used within a FirebaseProvider");
    }
    return context;
};

// --- Types ---
type UserRole = 'admin' | 'member' | 'news_contributor' | 'podcast_contributor';
type User = { id: string; name: string; email: string; avatar: string; roles: UserRole[]; fcmTokens?: string[] };
type Church = { id: string; name: string; logo: string; offeringDetails: any; };
type Comment = { id: string; authorId: string; authorName: string; authorAvatar: string; content: string; createdAt: Timestamp; };
type PrayerRequest = { id:string; authorId: string; authorName: string; title: string; content: string; image?: string | null; prayedBy: string[]; comments?: Comment[]; commentCount?: number; createdAt: Timestamp; status?: 'uploading' | 'failed'; tempId?: string; localImagePreview?: string; };
type Podcast = { id: string; title: string; authorId: string; authorName: string; audioUrl: string; createdAt: Timestamp; status?: 'uploading' | 'failed'; tempId?: string; localAudioUrl?: string; };
type NewsItem = { id: string; title: string; content: string; image?: string | null; createdAt: Timestamp; authorId: string, authorName: string; status?: 'uploading' | 'failed'; tempId?: string; localImagePreview?: string; };
type Verse = { verse: string; text: string; };

type MediaItem = {
    url: string;
    type: 'image' | 'video';
    path?: string; // For deletion from storage
};
type Message = {
    id: string;
    senderId: string;
    content?: string;
    media?: MediaItem[];
    createdAt: Timestamp;
    status?: 'uploading' | 'failed';
    tempId?: string;
};

type LastMessage = {
    content: string;
    senderId: string;
    createdAt: Timestamp;
};

type Chat = { 
    id: string; 
    participantIds: string[]; 
    participants: { [key: string]: { name: string; avatar: string; } }; // Simplified participant info
    lastMessage?: LastMessage;
    lastRead?: { [key: string]: Timestamp };
    lastActivity?: Timestamp;
};

type Notification = {
    id: string;
    icon: string; // material symbol name
    message: string;
    timestamp: string;
};
type WorshipService = {
    id: string;
    isLive: boolean;
    streamUrl: string;
    title: string;
    createdAt: Timestamp;
};

type PastWorshipService = {
    id: string;
    title: string;
    youtubeUrl: string;
    createdAt: Timestamp;
};


// --- Static Config & Data ---
const CHURCH: Church = {
    id: 'nepal_logos', name: 'Logos Church, Nepal', logo: '/logos-church-new-logo.jpg',
    offeringDetails: { qrCodeUrl: '/logos-qr-code.png', bankName: 'Global IME Bank', accountHolder: 'YAM PRADHAN', accountNumber: '10507010042662' },
};

const MOCK_VERSES_OF_THE_DAY: Verse[] = [
    { verse: 'यूहन्ना ३:१६', text: 'किनभने परमेश्‍वरले संसारलाई यति साह्रो प्रेम गर्नुभयो, कि उहाँले आफ्‍ना एकमात्र पुत्र दिनुभयो, ताकि उहाँमाथि विश्‍वास गर्ने कोही पनि नाश नहोस्, तर त्‍यसले अनन्त जीवन पाओस्।' },
    { verse: 'फिलिप्पी ४:१३', text: 'जसले मलाई शक्ति दिनuहुन्छ, उहाँमा म सब कुरा गर्न सक्छु।' },
    { verse: 'रोमी ८:२८', text: 'हामी जान्दछौं, कि परमेश्‍वरलाई प्रेम गर्नेहरूका निम्ति, अर्थात् उहाँको अभिप्रायअनुसार बोलाइएकाहरूका निम्ति हरेक कुरामा परमेश्‍वरले भलाइ नै गर्नुहुन्छ।' },
    { verse: 'यशैया ४१:१०', text: 'नडरा, किनभने म तँसँग छु। निरुत्साहित नहो, किनभने म तेरो परमेश्‍वर हुँ। म तँलाई बलियो पार्नेछु, म तँलाई सहायता गर्नेछु, म तँलाई मेरो धार्मिकताको दाहिने हातले समाल्नेछु।' },
    { verse: 'भजनसंग्रह २३:१', text: 'परमप्रभु मेरो गोठालो हुनुहुन्छ, मलाई केही कुराको अभाव हुनेछैन।' },
    { verse: 'यर्मिया २९:११', text: 'किनभने मैले तिमीहरूका निम्ति बनाएका योजनाहरू म जान्दछछु,” परमप्रभु भन्नुहुन्छ, “तिमीहरूलाई हानि गर्ने होइन, तर उन्नति गर्ने योजनाहरू, तिमीहरूलाई आशा र भविष्य दिने योजनाहरू।' },
    { verse: 'मत्ती ११:२८', text: 'हे सबै थाकेका र बोझले दबिएका हो, मकहाँ आओ, र म तिमीहरूलाई विश्राम दिनेछु।' },
    { verse: 'हितोपदेश ३:५-६', text: 'तेरो सारा हृदयले परमप्रभुमाथि भरोसा राख्, र तेरो आफ्नै समझशक्तिमाथि भर नपर्। तेरा सबै मार्गहरूमा उहाँलाई स्वीकार गर्, र उहाँले तेरा मार्गहरू सोझो बनाउनुहुनेछ।' },
    { verse: '२ तिमोथी १:७', text: 'किनभने परमेश्‍वरले हामीलाई डरको आत्मा दिनुभएको छैन, तर शक्ति, प्रेम र आत्मसंयमको आत्मा दिनुभएको छ।' },
    { verse: 'यहोशू १:९', text: 'के मैले तँलाई आज्ञa दिएको छैनँ र? बलियो र साहसी हो। नडरा, न त निरुत्साहित हो, किनभने तँ जहाँ गए पनि परमप्रभु तेरा परमेश्‍वर तँसँग हुनुहुन्छ।' },
    { verse: 'भजनसंग्रह ४६:१', text: 'परमेश्‍वर हाम्रा शरणस्थान र बल हुनुहुन्छ, सङ्कष्टमा तुरुन्तै पाइने सहायक।' },
    { verse: 'मत्ती ६:३३', text: 'तर पहिले उहाँको राज्य र उहाँको धार्मिकताको खोजी गर, र यी सबै कुरा तिमीहरूलाई थपिनेछन्।' },
    { verse: 'गलाती ५:२२-২৩', text: 'तर पवित्र आत्माको फलचाहिँ प्रेम, आनन्द, शान्ति, धैर्य, दया, भलाइ, विश्वस्तता, नम्रता र आत्मसंयम हो।' },
    { verse: 'हिब्रू ११:१', text: 'अब विश्वासचाहिँ आशा राखिएका कुराहरूको निश्चय र नदेखिएका कुराहरूको प्रमाण हो।' },
    { verse: 'रोमी १०:९', text: 'यदि तपाईंले आफ्नो मुखले “येशू नै प्रभु हुनुहुन्छ” भनी स्वीकार गर्नुभयो र परमेश्वरले उहाँलाई मरेकाहरूबाट जीवित पार्नुभयो भनी आफ्नो हृदयमा विश्वास गर्नुभयो भने तपाईंले उद्धार पाउनुहुनेछ।' },
    { verse: 'भजनसंग्रह १:१-२', text: 'धन्य हो त्यो मानिस, जो दुष्टहरूको सल्लाहमा हिँड्दैन, र पापीहरूको मार्गमा खडा हुँदैन, र गिल्ला गर्नेहरूको संगतमा बस्दैन। तर त्यसको खुशी परमप्रभुको व्यवस्थामा रहन्छ, र त्यसले दिनरात उहाँको व्यवस्थामा ध्यान गर्छ।' },
    { verse: 'यशैया ४०:३१', text: 'तर परमप्रभुमा आशा राख्नेहरूले नयाँ शक्ति प्राप्त गर्नेछन्। तिनीहरू गरुडझैं पखेटा लाएर माथि उड्नेछन्। तिनीहरू दगुरेर जानेछन् र थकित हुनेछैनन्, तिनीहरू हिँड्नेछन् र मूर्छित हुनेछैनन्।' },
    { verse: '१ कोरिन्थी १०:१३', text: 'तिमीहरूमाथि आइपरेको कुनै पनि परीक्षा मानिसलाई साधारणतया आइपर्नेभन्दा बाहिरको छैन। र परमेश्वर विश्वासयोग्य हुनुहुन्छ। उहाँले तिमीहरूलाई तिमीहरूको शक्तिभन्दा बाहिरको परीक्षामा पर्न दिनुहुनेछैन।' },
    { verse: 'एफिसी २:८-९', text: 'किनभने अनुग्रहबाट विश्वासद्वारा तिमीहरूले उद्धार पाएका छौ—र यो तिमीहरू आफैबाट होइन, यो परमेश्वरको वरदान हो—कर्महरूद्वारा होइन, ताकि कसैले घमण्ड गर्न नपाओस्।' },
    { verse: 'भजनसंग्रह ३७:४', text: 'परमप्रभुमा आनन्दित हो, र उहाँले तेरो हृदयका इच्छाहरू पूरा गर्नुहुनेछ।' },
    { verse: '२ कोरिन्थी ५:१७', text: 'यसकारण, यदि कोही ख्रीष्टमा छ भने, ऊ नयाँ सृष्टि हो। पुरानो बितिगएको छ, हेर, नयाँ आएको छ!' },
    { verse: 'हितोपदेश २२:६', text: 'बालकलाई त्यसको हिँड्नुपर्ने बाटोमा तालिम दे, र ऊ बूढो हुँदा पनि त्यसबाट तर्कनेछैन।' },
    { verse: 'भजनसंग्रह ११९:१०५', text: 'तपाईंको वचन मेरो खुट्टाको निम्ति बत्ती, र मेरो बाटोको निम्ति उज्यालो हो।' }
];

const MCCHEYNE_READING_PLAN = [
    "उत्पत्ति १, मत्ती १, एज्रा १, प्रेरित १",
    "उत्पत्ति २, मत्ती २, एज्रा २, प्रेरित २",
    "उत्पत्ति ३, मत्ती ३, एज्रा ३, प्रेरित ३",
    "उत्पत्ति ४, मत्ती ४, एज्रा ४, प्रेरित ४",
    "उत्पत्ति ५, मत्ती ५, एज्रा ५, प्रेरित ५",
    "उत्पत्ति ६, मत्ती ६, एज्रा ६, प्रेरित ६",
    "उत्पत्ति ७, मत्ती ७, एज्रा ७, प्रेरित ७",
    "उत्पत्ति ८, मत्ती ८, एज्रा ८, प्रेरित ८",
    "उत्पत्ति ९, मत्ती ९, एज्रा ९, प्रेरित ९",
    "उत्पत्ति १०, मत्ती १०, एज्रा १०, प्रेरित १०",
    "उत्पत्ति ११, मत्ती ११, नहेम्याह १, प्रेरित ११",
    "उत्पत्ति १२, मत्ती १२, नहेम्याह २, प्रेरित १२",
    "उत्पत्ति १३, मत्ती १३, नहेम्याह ३, प्रेरित १३",
    "उत्पत्ति १४, मत्ती १४, नहेम्याह ४, प्रेरित १४",
    "उत्पत्ति १५, मत्ती १५, नहेम्याह ५, प्रेरित १५",
    "उत्पत्ति १६, मत्ती १६, नहेम्याह ६, प्रेरित १६",
    "उत्पत्ति १७, मत्ती १७, नहेम्याह ७, प्रेरित १७",
    "उत्पत्ति १८, मत्ती १८, नहेम्याह ८, प्रेरित १८",
    "उत्पत्ति १९, मत्ती १९, नहेम्याह ९, प्रेरित १९",
    "उत्पत्ति २०, मत्ती २०, नहेम्याह १०, प्रेरित २०",
    "उत्पत्ति २१, मत्ती २१, नहेम्याह ११, प्रेरित २१",
    "उत्पत्ति २२, मत्ती २२, नहेम्याह १२, प्रेरित २२",
    "उत्पत्ति ২৩, मत्ती ২৩, नहेम्याह १३, प्रेरित ২৩",
    "उत्पत्ति २४, मत्ती २४, एस्तर १, प्रेरित २४",
    "उत्पत्ति २५, मत्ती २५, एस्तर २, प्रेरित २५",
    "उत्पत्ति २६, मत्ती २６, एस्तर ३, प्रेरित २६",
    "उत्पत्ति २७, मत्ती २७, एस्तर ४, प्रेरित २७",
    "उत्पत्ति २८, मत्ती २८, एस्तर ५, प्रेरित २८",
    "उत्पत्ति २९, मर्कूस १, एस्तर ६, रोमी १",
    "उत्पत्ति ३०, मर्कूस २, एस्तर ७, रोमी २",
    "उत्पत्ति ३१, मर्कूस ३, एस्तर ८, रोमी ३",
    "उत्पत्ति ३२, मर्कूस ४, एस्तर ९, रोमी ४",
    "उत्पत्ति ३३, मर्कूस ५, एस्तर १०, रोमी ५",
    "उत्पत्ति ३४, मर्कूस ६, अय्यूब १, रोमी ६",
    "उत्पत्ति ३५, मर्कूस ७, अय्यूब २, रोमी ७",
    "उत्पत्ति ३６, मर्कूस ८, अय्यूब ३, रोमी ८",
    "उत्पत्ति ३७, मर्कूस ९, अय्यूब ४, रोमी ९",
    "उत्पत्ति ३८, मर्कूस १०, अय्यूब ५, रोमी १०",
    "उत्पत्ति ३９, मर्कूस ११, अय्यूब ६, रोमी ११",
    "उत्पत्ति ४०, मर्कूस १२, अय्यूब ७, रोमी १२",
    "उत्पत्ति ४१, मर्कूस १३, अय्यूब ८, रोमी १३",
    "उत्पत्ति ४２, मर्कूस १४, अय्यूब ९, रोमी १४",
    "उत्पत्ति ४३, मर्कूस १५, अय्यूब १०, रोमी १५",
    "उत्पत्ति ４４, मर्कूस १६, अय्यूब ११, रोमी १६",
    "उत्पत्ति ४५, लूका १:१-३८, अय्यूब १२, १ कोरिन्थी १",
    "उत्पत्ति ४६, लूका १:३९-८०, अय्यूब १३, १ कोरिन्थी २",
    "उत्पत्ति ४７, लूका २:१-२४, अय्यूब १४, १ कोरिन्थी ३",
    "उत्पत्ति ४८, लूका २:२५-५２, अय्यूब १५, १ कोरिन्थी ४",
    "उत्पत्ति ४९, लूका ३, अय्यूब १६, १ कोरिन्थी ५",
    "उत्पत्ति ५०, लूका ४:१-३０, अय्यूब १७, १ कोरिन्थी ६",
    "प्रस्थान १, लूका ४:३१-४४, अय्यूब १८, १ कोरिन्थी ७",
    "प्रस्थान २, लूका ५:१-१６, अय्यूब १९, १ कोरिन्थी ८",
    "प्रस्थान ३, लूका ५:१७-३９, अय्यूब २०, १ कोरिन्थी ९",
    "प्रस्थान ४, लूका ६:१-१९, अय्यूब २१, १ कोरिन्थी १०",
    "प्रस्थान ५, लूका ६:२०-４９, अय्यूब २２, १ कोरिन्थी ११",
    "प्रस्थान ६, लूका ७:१-२३, अय्यूब २३, १ कोरिन्थी १२",
    "प्रस्थान ७, लूका ७:२४-५०, अय्यूब २४, १ कोरिन्थी १३",
    "प्रस्थान ८, लूका ८:१-२५, अय्यूब २५, १ कोरिन्थी १४",
    "प्रस्थान ९, लूका ८:२६-५６, अय्यूब २६, १ कोरिन्थी १५",
    "प्रस्थान १०, लूका ९:१-१८, अय्यूब २७, १ कोरिन्थी १६",
    "प्रस्थान ११, लूका ९:१९-३６, अय्यूब २८, २ कोरिन्थी १",
    "प्रस्थान १२, लूका ९:३७-६２, अय्यूब २९, २ कोरिन्थी २",
    "प्रस्थान १३, लूका १०:१-२４, अय्यूब ३०, २ कोरिन्थी ३",
    "प्रस्थान १४, लूका १०:२५-４２, अय्यूब ३१, २ कोरिन्थी ४",
    "प्रस्थान १५, लूका ११:१-२८, अय्यूब ३２, २ कोरिन्थी ५",
    "प्रस्थान १६, लूका ११:२९-５４, अय्यूब ३३, २ कोरिन्थी ६",
    "प्रस्थान १७, लूका १२:१-३４, अय्यूब ३४, २ कोरिन्थी ७",
    "प्रस्थान १८, लूका १२:३५-५९, अय्यूब ३５, २ कोरिन्थी ८",
    "प्रस्थान १९, लूका १३, अय्यूब ३６, २ कोरिन्थी ९",
    "प्रस्थान २०, लूका १४:१-२４, अय्यूब ३７, २ कोरिन्थी १०",
    "प्रस्थान २१, लूका १४:२५-३５, अय्यूब ३८, २ कोरिन्थी ११",
    "प्रस्थान २２, लूका १५, अय्यूब ३９, २ कोरिन्थी १२",
    "प्रस्थान ২৩, लूका १६, अय्यूब ४०, २ कोरिन्थी १३",
    "प्रस्थान २४, लूका १७:१-१९, अय्यूब ४१, गलाती १",
    "प्रस्थान २५, लूका १७:२०-३７, अय्यूब ४２, गलाती २",
    "प्रस्थान २६, लूका १८:१-१८, भजनसंग्रह १-२, गलाती ३",
    "प्रस्थान २७, लूका १८:१९-４３, भजनसंग्रह ३-४, गलाती ४",
    "प्रस्थान २८, लूका १९:१-२७, भजनसंग्रह ५-६, गलाती ५",
    "प्रस्थान २९, लूका १९:२८-４８, भजनसंग्रह ७, गलाती ६",
    "प्रस्थान ३०, लूका २०:१-१९, भजनसंग्रह ८, एफिसी १",
    "प्रस्थान ३１, लूका २०:२०-４७, भजनसंग्रह ९, एफिसी २",
    "प्रस्थान ३２, लूका २१, भजनसंग्रह १०, एफिसी ३",
    "प्रस्थान ३३, लूका २２:१-३０, भजनसंग्रह ११-१२, एफिसी ४",
    "प्रस्थान ३４, लूका २२:३१-५३, भजनसंग्रह १३-१४, एफिसी ५",
    "प्रस्थान ३５, लूका २२:५४-७１, भजनसंग्रह १५-१６, एफिसी ६",
    "प्रस्थान ३６, लूका ২৩:१-२५, भजनसंग्रह १७, फिलिप्पी १",
    "प्रस्थान ३７, लूका २३:२६-५６, भजनसंग्रह १८, फिलिप्पी २",
    "प्रस्थान ३८, लूका २४:१-१२, भजनसंग्रह १९, फिलिप्पी ३",
    "प्रस्थान ३９, लूका २४:१३-５３, भजनसंग्रह २०, फिलिप्पी ४",
    "प्रस्थान ४०, यूहन्ना १:१-२८, भजनसंग्रह २१, कलस्सी १",
    "लेवी १, यूहन्ना १:२९-५１, भजनसंग्रह २２, कलस्सी २",
    "लेवी २, यूहन्ना २, भजनसंग्रह ২৩, कलस्सी ३",
    "लेवी ३, यूहन्ना ३:१-२１, भजनसंग्रह २४, कलस्सी ४",
    "लेवी ४, यूहन्ना ३:२२-३６, भजनसंग्रह २५, १ थिस्सलोनिकी १",
    "लेवी ५, यूहन्ना ४:१-३０, भजनसंग्रह २६, १ थिस्सलोनिकी २",
    "लेवी ६, यूहन्ना ४:३१-５４, भजनसंग्रह २७, १ थिस्सलोनिकी ३",
    "लेवी ७, यूहन्ना ५:१-२३, भजनसंग्रह २८, १ थिस्सलोनिकी ४",
    "लेवी ८, यूहन्ना ५:２４-４७, भजनसंग्रह २९, १ थिस्सलोनिकी ५",
    "लेवी ९, यूहन्ना ६:१-२１, भजनसंग्रह ३०, २ थिस्सलोनिकी १",
    "लेवी १०, यूहन्ना ६:२２-４०, भजनसंग्रह ३１, २ थिस्सलोनिकी २",
    "लेवी ११, यूहन्ना ६:४१-७１, भजनसंग्रह ३２, २ थिस्सलोनिकी ३",
    "लेवी १२, यूहन्ना ७:१-३１, भजनसंग्रह ३३, १ तिमोथी १",
    "लेवी १३, यूहन्ना ७:३２-５३, भजनसंग्रह ३４, १ तिमोथी २",
    "लेवी १४, यूहन्ना ८:१-३０, भजनसंग्रह ३५, १ तिमोथी ३",
    "लेवी १५, यूहन्ना ८:३१-५९, भजनसंग्रह ३６, १ तिमोथी ४",
    "लेवी १६, यूहन्ना ९, भजनसंग्रह ३７, १ तिमोथी ५",
    "लेवी १७, यूहन्ना १०:१-२１, भजनसंग्रह ३８, १ तिमोथी ६",
    "लेवी १८, यूहन्ना १०:२२-４２, भजनसंग्रह ३９, २ तिमोथी १",
    "लेवी १९, यूहन्ना ११:१-२７, भजनसंग्रह ४०, २ तिमोथी २",
    "लेवी २०, यूहन्ना ११:२８-５７, भजनसंग्रह ४１, २ तिमोथी ३",
    "लेवी २१, यूहन्ना १२:१-१९, भजनसंग्रह ४２, २ तिमोथी ४",
    "लेवी २２, यूहन्ना १२:२०-５０, भजनसंग्रह ४३, तीतस १",
    "लेवी ২৩, यूहन्ना १३, भजनसंग्रह ۴４, तीतस २",
    "लेवी २४, यूहन्ना १४, भजनसंग्रह ४５, तीतस ३",
    "लेवी २५, यूहन्ना १५, भजनसंग्रह ४６, फिलेमोन १",
    "लेवी २６, यूहन्ना १६, भजनसंग्रह ४７, हिब्रू १",
    "लेवी २७, यूहन्ना १७, भजनसंग्रह ४８, हिब्रू २",
    "गन्ती १, यूहन्ना १८:१-२३, भजनसंग्रह ४९, हिब्रू ३",
    "गन्ती २, यूहन्ना १८:２４-４०, भजनसंग्रह ५０, हिब्रू ४",
    "गन्ती ३, यूहन्ना १९:१-२２, भजनसंग्रह ५१, हिब्रू ५",
    "गन्ती ४, यूहन्ना १९:२３-４２, भजनसंग्रह ५２, हिब्रू ६",
    "गन्ती ५, यूहन्ना २०, भजनसंग्रह ५３, हिब्रू ७",
    "गन्ती ६, यूहन्ना २１, भजनसंग्रह ५４, हिब्रू ८",
    "गन्ती ७, प्रेरित १, भजनसंग्रह ५５, हिब्रू ९",
    "गन्ती ८, प्रेरित २:१-२１, भजनसंग्रह ५６, हिब्रू १०",
    "गन्ती ९, प्रेरित २:२２-４७, भजनसंग्रह ५７, हिब्रू ११",
    "गन्ती १०, प्रेरित ३, भजनसंग्रह ५８, हिब्रू १२",
    "गन्ती ११, प्रेरित ४:१-२２, भजनसंग्रह ५९, हिब्रू १३",
    "गन्ती १२, प्रेरित ४:२३-３７, भजनसंग्रह ६０, याकूब १",
    "गन्ती १३, प्रेरित ५:१-१८, भजनसंग्रह ६１, याकूब २",
    "गन्ती १४, प्रेरित ५:१९-４２, भजनसंग्रह ६２, याकूब ३",
    "गन्ती १५, प्रेरित ६, भजनसंग्रह ६３, याकूब ४",
    "गन्ती १६, प्रेरित ७:१-२１, भजनसंग्रह ६４, याकूब ५",
    "गन्ती १७, प्रेरित ७:२２-４३, भजनसंग्रह ६５, १ पत्रुस १",
    "गन्ती १८, प्रेरित ७:४４-６०, भजनसंग्रह ६６, १ पत्रुस २",
    "गन्ती १९, प्रेरित ८:१-२५, भजनसंग्रह ६७, १ पत्रुस ३",
    "गन्ती २०, प्रेरित ८:２６-４०, भजनसंग्रह ६８, १ पत्रुस ४",
    "गन्ती २१, प्रेरित ९:१-२１, भजनसंग्रह ६९, १ पत्रुस ५",
    "गन्ती २２, प्रेरित ९:२२-４३, भजनसंग्रह ७０, २ पत्रुस १",
    "गन्ती ২৩, प्रेरित १०:१-२३, भजनसंग्रह ७１, २ पत्रुस २",
    "गन्ती २४, प्रेरित १०:२４-４८, भजनसंग्रह ७２, २ पत्रुस ३",
    "गन्ती २५, प्रेरित ११, भजनसंग्रह ७３, १ यूहन्ना १",
    "गन्ती २६, प्रेरित १२, भजनसंग्रह ७４, १ यूहन्ना २",
    "गन्ती २७, प्रेरित १३:१-२５, भजनसंग्रह ७５, १ यूहन्ना ३",
    "गन्ती २८, प्रेरित १३:२６-５２, भजनसंग्रह ७６, १ यूहन्ना ४",
    "गन्ती २९, प्रेरित १४, भजनसंग्रह ७７, १ यूहन्ना ५",
    "गन्ती ३０, प्रेरित १५:१-२१, हितोपदेश १, २ यूहन्ना १",
    "गन्ती ३１, प्रेरित १५:२２-４１, हितोपदेश २, ३ यूहन्ना १",
    "गन्ती ३２, प्रेरित १६, हितोपदेश ३, यहूदा १",
    "गन्ती ३३, प्रेरित १७:१-१５, हितोपदेश ४, प्रकाश १",
    "गन्ती ३４, प्रेरित १७:१६-３４, हितोपदेश ५, प्रकाश २",
    "गन्ती ३５, प्रेरित १८, हितोपदेश ६, प्रकाश ३",
    "गन्ती ३６, प्रेरित १९, हितोपदेश ७, प्रकाश ४",
    "व्यवस्था १, प्रेरित २०:१-१６, हितोपदेश ८, प्रकाश ५",
    "व्यवस्था २, प्रेरित २०:१７-३८, हितोपदेश ९, प्रकाश ६",
    "व्यवस्था ३, प्रेरित २१:१-१८, उपदेशक १, प्रकाश ७",
    "व्यवस्था ४, प्रेरित २१:१९-４३, उपदेशक २, प्रकाश ८",
    "व्यवस्था ५, प्रेरित २２, उपदेशक ३, प्रकाश ९",
    "व्यवस्था ६, प्रेरित ২৩, उपदेशक ४, प्रकाश १०",
    "व्यवस्था ७, प्रेरित २४, उपदेशक ५, प्रकाश ११",
    "व्यवस्था ८, प्रेरित २५, उपदेशक ६, प्रकाश १२",
    "व्यवस्था ९, प्रेरित २６, उपदेशक ७, प्रकाश १३",
    "व्यवस्था १०, प्रेरित २７, उपदेशक ८, प्रकाश १४",
    "व्यवस्था ११, प्रेरित २８, उपदेशक ९, प्रकाश १५",
    "व्यवस्था १२, रोमी १, उपदेशक १०, प्रकाश १६",
    "व्यवस्था १३, रोमी २, उपदेशक ११, प्रकाश १७",
    "व्यवस्था १४, रोमी ३, उपदेशक १२, प्रकाश १८",
    "व्यवस्था १५, रोमी ४, श्रेष्ठगीत १, प्रकाश १९",
    "व्यवस्था १६, रोमी ५, श्रेष्ठगीत २, प्रकाश २०",
    "व्यवस्था १७, रोमी ६, श्रेष्ठगीत ३, प्रकाश २१",
    "व्यवस्था १८, रोमी ७, श्रेष्ठगीत ४, प्रकाश २２",
    "व्यवस्था १९, रोमी ८:१-१८, श्रेष्ठगीत ५, यशैया १",
    "व्यवस्था २०, रोमी ८:१९-३９, श्रेष्ठगीत ६, यशैया २",
    "व्यवस्था २१, रोमी ९, श्रेष्ठगीत ७, यशैया ३",
    "व्यवस्था २２, रोमी १०, श्रेष्ठगीत ८, यशैया ४",
    "व्यवस्था ২৩, रोमी ११:१-२４, यशैया १, यशैया ५",
    "व्यवस्था २४, रोमी ११:२５-३６, यशैया २, यशैया ६",
    "व्यवस्था २५, रोमी १२, यशैया ३, यशैया ७",
    "व्यवस्था २６, रोमी १३, यशैया ४, यशैया ८",
    "व्यवस्था २७, रोमी १४, यशैया ५, यशैया ९",
    "व्यवस्था २८, रोमी १५:१-१८, यशैया ६, यशैया १०",
    "व्यवस्था २९, रोमी १५:१९-３３, यशैया ७, यशैया ११",
    "व्यवस्था ३０, रोमी १६, यशैया ८, यशैया १२",
    "व्यवस्था ३１, १ कोरिन्थी १, यशैया ९, यशैया १३",
    "व्यवस्था ३２, १ कोरिन्थी २, यशैया १०, यशैया १४",
    "व्यवस्था ३３, १ कोरिन्थी ३, यशैया ११, यशैया १५",
    "व्यवस्था ३４, १ कोरिन्थी ४, यशैया १२, यशैया १६",
    "यहोशू १, १ कोरिन्थी ५, यशैया १३, यशैया १७",
    "यहोशू २, १ कोरिन्थी ६, यशैया १४, यशैया १८",
    "यहोशू ३, १ कोरिन्थी ७, यशैया १५, यशैया १९",
    "यहोशू ४, १ कोरिन्थी ८, यशैया १६, यशैया २०",
    "यहोशू ५, १ कोरिन्थी ९, यशैया १७, यशैया २१",
    "यहोशू ६, १ कोरिन्थी १०, यशैया १८, यशैया २２",
    "यहोशू ७, १ कोरिन्थी ११, यशैया १९, यशैया ২৩",
    "यहोशू ८, १ कोरिन्थी १२, यशैया २०, यशैया २४",
    "यहोशू ९, १ कोरिन्थी १३, यशैया २१, यशैया २५",
    "यहोशू १०, १ कोरिन्थी १४, यशैया २２, यशैया २६",
    "यहोशू ११, १ कोरिन्थी १५, यशैया ২৩, यशैया २７",
    "यहोशू १२, १ कोरिन्थी १६, यशैया २४, यशैया २८",
    "यहोशू १३, २ कोरिन्थी १, यशैया २५, यशैया २९",
    "यहोशू १४, २ कोरिन्थी २, यशैया २६, यशैया ३०",
    "यहोशू १५, २ कोरिन्थी ३, यशैया २७, यशैया ३１",
    "यहोशू १६, २ कोरिन्थी ४, यशैया २८, यशैया ३２",
    "यहोशू १७, २ कोरिन्थी ५, यशैया २९, यशैया ३３",
    "यहोशू १८, २ कोरिन्थी ६, यशैया ३０, यशैया ३４",
    "यहोशू १९, २ कोरिन्थी ७, यशैया ३１, यशैया ३５",
    "यहोशू २०, २ कोरिन्थी ८, यशैया ३２, यशैया ३６",
    "यहोशू २१, २ कोरिन्थी ९, यशैया ३３, यशैया ३７",
    "यहोशू २２, २ कोरिन्थी १०, यशैया ३４, यशैया ३８",
    "यहोशू ২৩, २ कोरिन्थी ११, यशैया ३５, यशैया ३९",
    "यहोशू २४, २ कोरिन्थी १२, यशैया ३６, यशैया ४０",
    "न्यायकर्ता १, २ कोरिन्थी १३, यशैया ३７, यशैया ४１",
    "न्यायकर्ता २, गलाती १, यशैया ३８, यशैया ४２",
    "न्यायकर्ता ३, गलाती २, यशैया ३९, यशैया ४３",
    "न्यायकर्ता ४, गलाती ३, यशैया ४०, यशैया ४４",
    "न्यायकर्ता ५, गलाती ४, यर्मिया १, यशैया ४５",
    "न्यायकर्ता ६, गलाती ५, यर्मिया २, यशैया ४６",
    "न्यायकर्ता ७, गलाती ६, यर्मिया ३, यशैया ४７",
    "न्यायकर्ता ८, एफिसी १, यर्मिया ४, यशैया ४८",
    "न्यायकर्ता ९, एफिसी २, यर्मिया ५, यशैया ४９",
    "न्यायकर्ता १०, एफिसी ३, यर्मिया ६, यशैया ५０",
    "न्यायकर्ता ११, एफिसी ४, यर्मिया ७, यशैया ५１",
    "न्यायकर्ता १२, एफिसी ५, यर्मिया ८, यशैया ५２",
    "न्यायकर्ता १३, एफिसी ६, यर्मिया ९, यशैया ५３",
    "न्यायकर्ता १४, फिलिप्पी १, यर्मिया १०, यशैया ५４",
    "न्यायकर्ता १५, फिलिप्पी २, यर्मिया ११, यशैया ५५",
    "न्यायकर्ता १६, फिलिप्पी ३, यर्मिया १२, यशैया ५６",
    "न्यायकर्ता १७, फिलिप्पी ४, यर्मिया १३, यशैया ५７",
    "न्यायकर्ता १८, कलस्सी १, यर्मिया १४, यशैया ५８",
    "न्यायकर्ता १९, कलस्सी २, यर्मिया १५, यशैया ५９",
    "न्यायकर्ता २०, कलस्सी ३, यर्मिया १६, यशैया ६０",
    "न्यायकर्ता २१, कलस्सी ४, यर्मिया १७, यशैया ६１",
    "रूथ १, १ थिस्सलोनिकी १, यर्मिया १८, यशैया ६２",
    "रूथ २, १ थिस्सलोनिकी २, यर्मिया १९, यशैया ६３",
    "रूथ ३, १ थिस्सलोनिकी ३, यर्मिया २०, यशैया ६４",
    "रूथ ४, १ थिस्सलोनिकी ४, यर्मिया २१, यशैया ६５",
    "१ शमूएल १, १ थिस्सलोनिकी ५, यर्मिया २２, यशैया ६６",
    "१ शमूएल २, २ थिस्सलोनिकी १, यर्मिया ২৩, विलाप १",
    "१ शमूएल ३, २ थिस्सलोनिकी २, यर्मिया २४, विलाप २",
    "१ शमूएल ४, २ थिस्सलोनिकी ३, यर्मिया २५, विलाप ३",
    "१ शमूएल ५, १ तिमोथी १, यर्मिया २६, विलाप ४",
    "१ शमूएल ६, १ तिमोथी २, यर्मिया २७, विलाप ५",
    "१ शमूएल ७, १ तिमोथी ३, यर्मिया २８, इजकिएल १",
    "१ शमूएल ८, १ तिमोथी ४, यर्मिया २९, इजकिएल २",
    "१ शमूएल ९, १ तिमोथी ५, यर्मिया ३०, इजकिएल ३",
    "१ शमूएल १०, १ तिमोथी ६, यर्मिया ३１, इजकिएल ४",
    "१ शमूएल ११, २ तिमोथी १, यर्मिया ३２, इजकिएल ५",
    "१ शमूएल १२, २ तिमोथी २, यर्मिया ३３, इजकिएल ६",
    "१ शमूएल १३, २ तिमोथी ३, यर्मिया ३４, इजकिएल ७",
    "१ शमूएल १४, २ तिमोथी ४, यर्मिया ३５, इजकिएल ८",
    "१ शमूएल १५, तीतस १, यर्मिया ३６, इजकिएल ९",
    "१ शमूएल १६, तीतस २, यर्मिया ३７, इजकिएल १०",
    "१ शमूएल १७, तीतस ३, यर्मिया ३８, इजकिएल ११",
    "१ शमूएल १८, फिलेमोन १, यर्मिया ३９, इजकिएल १२",
    "१ शमूएल १९, हिब्रू १, यर्मिया ४०, इजकिएल १३",
    "१ शमूएल २०, हिब्रू २, यर्मिया ४१, इजकिएल १४",
    "१ शमूएल २१, हिब्रू ३, यर्मिया ४２, इजकिएल १५",
    "१ शमूएल २２, हिब्रू ४, यर्मिया ४３, इजकिएल १६",
    "१ शमूएल ২৩, हिब्रू ५, यर्मिया ४４, इजकिएल १७",
    "१ शमूएल २४, हिब्रू ६, यर्मिया ४５, इजकिएल १८",
    "१ शमूएल २५, हिब्रू ७, यर्मिया ४６, इजकिएल १९",
    "१ शमूएल २६, हिब्रू ८, यर्मिया ४７, इजकिएल २०",
    "१ शमूएल २７, हिब्रू ९, यर्मिया ४８, इजकिएल २१",
    "१ शमूएल २८, हिब्रू १०, यर्मिया ४９, इजकिएल २２",
    "१ शमूएल २९, हिब्रू ११, यर्मिया ५０, इजकिएल ২৩",
    "१ शमूएल ३０, हिब्रू १२, यर्मिया ५１, इजकिएल २४",
    "१ शमूएल ३１, हिब्रू १३, यर्मिया ५２, इजकिएल २५",
    "२ शमूएल १, याकूब १, दानिएल १, इजकिएल २６",
    "२ शमूएल २, याकूब २, दानिएल २, इजकिएल २７",
    "२ शमूएल ३, याकूब ३, दानिएल ३, इजकिएल २८",
    "२ शमूएल ४, याकूब ४, दानिएल ४, इजकिएल २९",
    "२ शमूएल ५, याकूब ५, दानिएल ५, इजकिएल ३０",
    "२ शमूएल ६, १ पत्रुस १, दानिएल ६, इजकिएल ३１",
    "२ शमूएल ७, १ पत्रुस २, दानिएल ७, इजकिएल ३２",
    "२ शमूएल ८, १ पत्रुस ३, दानिएल ८, इजकिएल ३３",
    "२ शमूएल ९, १ पत्रुस ४, दानिएल ९, इजकिएल ३４",
    "२ शमूएल १०, १ पत्रुस ५, दानिएल १०, इजकिएल ३５",
    "२ शमूएल ११, २ पत्रुस १, दानिएल ११, इजकिएल ३６",
    "२ शमूएल १२, २ पत्रुस २, दानिएल १२, इजकिएल ३７",
    "२ शमूएल १३, २ पत्रुस ३, होशे १, इजकिएल ३８",
    "२ शमूएल १४, १ यूहन्ना १, होशे २, इजकिएल ३９",
    "२ शमूएल १५, १ यूहन्ना २, होशे ३, इजकिएल ४०",
    "२ शमूएल १६, १ यूहन्ना ३, होशे ४, इजकिएल ४１",
    "२ शमूएल १७, १ यूहन्ना ४, होशे ५, इजकिएल ४２",
    "२ शमूएल १८, १ यूहन्ना ५, होशे ६, इजकिएल ४３",
    "२ शमूएल १९, २ यूहन्ना १, होशे ७, इजकिएल ४４",
    "२ शमूएल २०, ३ यूहन्ना १, होशे ८, इजकिएल ४５",
    "२ शमूएल २१, यहूदा १, होशे ९, इजकिएल ४６",
    "२ शमूएल २２, प्रकाश १, होशे १०, इजकिएल ४７",
    "२ शमूएल ২৩, प्रकाश २, होशे ११, इजकिएल ४８",
    "२ शमूएल २४, प्रकाश ३, होशे १२, योएल १",
    "१ राजा १, प्रकाश ४, होशे १३, योएल २",
    "१ राजा २, प्रकाश ५, होशे १४, योएल ३",
    "१ राजा ३, प्रकाश ६, आमोस १, आमोस २",
    "१ राजा ४, प्रकाश ७, आमोस ३, आमोस ४",
    "१ राजा ५, प्रकाश ८, आमोस ५, आमोस ६",
    "१ राजा ६, प्रकाश ९, आमोस ७, आमोस ८",
    "१ राजा ७, प्रकाश १०, आमोस ९, ओबद्या १",
    "१ राजा ८, प्रकाश ११, योना १, योना २",
    "१ राजा ९, प्रकाश १२, योना ३, योना ४",
    "१ राजा १०, प्रकाश १३, मीका १, मीका २",
    "१ राजा ११, प्रकाश १४, मीका ३, मीका ४",
    "१ राजा १२, प्रकाश १५, मीका ५, मीका ६",
    "१ राजा १३, प्रकाश १६, मीका ७, नहूम १",
    "१ राजा १४, प्रकाश १७, नहूम २, नहूम ३",
    "१ राजा १५, प्रकाश १८, हबकूक १, हबकूक २",
    "१ राजा १६, प्रकाश १९, हबकूक ३, सपन्याह १",
    "१ राजा १७, प्रकाश २०, सपन्याह २, सपन्याह ३",
    "१ राजा १८, प्रकाश २१, हाग्गै १, हाग्गै २",
    "१ राजा १९, प्रकाश २２, जकरिया १, जकरिया २",
    "१ राजा २०, मत्ती १, जकरिया ३, जकरिया ४",
    "१ राजा २१, मत्ती २, जकरिया ५, जकरिया ६",
    "१ राजा २２, मत्ती ३, जकरिया ७, जकरिया ८",
    "२ राजा १, मत्ती ४, जकरिया ९, जकरिया १०",
    "२ राजा २, मत्ती ५, जकरिया ११, जकरिया १२",
    "२ राजा ३, मत्ती ६, जकरिया १३, जकरिया १४",
    "२ राजा ४, मत्ती ७, मलाकी १, मलाकी २",
    "२ राजा ५, मत्ती ८, मलाकी ३, मलाकी ४",
    "२ राजा ६, मत्ती ९, भजनसंग्रह १-२, भजनसंग्रह ३",
    "२ राजा ७, मत्ती १०, भजनसंग्रह ४-५, भजनसंग्रह ६",
    "२ राजा ८, मत्ती ११, भजनसंग्रह ७, भजनसंग्रह ८",
    "२ राजा ९, मत्ती १२, भजनसंग्रह ९, भजनसंग्रह १०",
    "२ राजा १०, मत्ती १३, भजनसंग्रह ११-१२, भजनसंग्रह १३",
    "२ राजा ११, मत्ती १४, भजनसंग्रह १४, भजनसंग्रह १५",
    "२ राजा १२, मत्ती १५, भजनसंग्रह १६, भजनसंग्रह १७",
    "२ राजा १३, मत्ती १६, भजनसंग्रह १८, भजनसंग्रह १९",
    "२ राजा १४, मत्ती १७, भजनसंग्रह २०, भजनसंग्रह २१",
    "२ राजा १५, मत्ती १८, भजनसंग्रह २２, भजनसंग्रह ২৩",
    "२ राजा १६, मत्ती १९, भजनसंग्रह २४, भजनसंग्रह २५",
    "२ राजा १७, मत्ती २०, भजनसंग्रह २６, भजनसंग्रह २７",
    "२ राजा १८, मत्ती २१, भजनसंग्रह २８, भजनसंग्रह २९",
    "२ राजा १९, मत्ती २２, भजनसंग्रह ३०, भजनसंग्रह ३１",
    "२ राजा २०, मत्ती ২৩, भजनसंग्रह ३２, भजनसंग्रह ३３",
    "२ राजा २१, मत्ती २४, भजनसंग्रह ३４, भजनसंग्रह ३５",
    "२ राजा २２, मत्ती २५, भजनसंग्रह ३６, भजनसंग्रह ३７",
    "२ राजा ২৩, मत्ती २６, भजनसंग्रह ३８, भजनसंग्रह ३９",
    "२ राजा २४, मत्ती २７, भजनसंग्रह ४०, भजनसंग्रह ४１",
    "२ राजा २५, मत्ती २８, भजनसंग्रह ४２, भजनसंग्रह ४３",
    "१ इतिहास १, मर्कूस १, भजनसंग्रह ४４, भजनसंग्रह ४５",
    "१ इतिहास २, मर्कूस २, भजनसंग्रह ४６, भजनसंग्रह ४７",
    "१ इतिहास ३, मर्कूस ३, भजनसंग्रह ४８, भजनसंग्रह ४９",
    "१ इतिहास ४, मर्कूस ४, भजनसंग्रह ५０, भजनसंग्रह ५１",
    "१ इतिहास ५, मर्कूस ५, भजनसंग्रह ५２, भजनसंग्रह ५３",
    "१ इतिहास ६, मर्कूस ६, भजनसंग्रह ५４, भजनसंग्रह ५５",
    "१ इतिहास ७, मर्कूस ७, भजनसंग्रह ५６, भजनसंग्रह ५７",
    "१ इतिहास ८, मर्कूस ८, भजनसंग्रह ५８, भजनसंग्रह ५９",
    "१ इतिहास ९, मर्कूस ९, भजनसंग्रह ६０, भजनसंग्रह ६１",
    "१ इतिहास १०, मर्कूस १०, भजनसंग्रह ६２, भजनसंग्रह ६３",
    "१ इतिहास ११, मर्कूस ११, भजनसंग्रह ६４, भजनसंग्रह ६５",
    "१ इतिहास १२, मर्कूस १२, भजनसंग्रह ६６, भजनसंग्रह ६７",
    "१ इतिहास १३, मर्कूस १३, भजनसंग्रह ६８, भजनसंग्रह ६９",
    "१ इतिहास १४, मर्कूस १४, भजनसंग्रह ७０, भजनसंग्रह ७１",
    "१ इतिहास १५, मर्कूस १५, भजनसंग्रह ७２, भजनसंग्रह ७３",
    "१ इतिहास १६, मर्कूस १६, भजनसंग्रह ७４, भजनसंग्रह ७５",
    "१ इतिहास १७, लूका १:१-३८, भजनसंग्रह ७６, भजनसंग्रह ७７",
    "१ इतिहास १८, लूका १:३९-８０, हितोपदेश १०, भजनसंग्रह ७８",
    "१ इतिहास १९, लूका २, हितोपदेश ११, भजनसंग्रह ७９",
    "१ इतिहास २०, लूका ३, हितोपदेश १२, भजनसंग्रह ८０",
    "१ इतिहास २１, लूका ४, हितोपदेश १३, भजनसंग्रह ८１",
    "१ इतिहास २２, लूका ५, हितोपदेश १४, भजनसंग्रह ८２",
    "१ इतिहास ২৩, लूका ६, हितोपदेश १५, भजनसंग्रह ८３",
    "१ इतिहास २४, लूका ७, हितोपदेश १६, भजनसंग्रह ८４",
    "१ इतिहास २५, लूका ८, हितोपदेश १७, भजनसंग्रह ८５",
    "१ इतिहास २６, लूका ९, हितोपदेश १८, भजनसंग्रह ८６",
    "१ इतिहास २७, लूका १०, हितोपदेश १९, भजनसंग्रह ८７",
    "१ इतिहास २８, लूका ११, हितोपदेश २०, भजनसंग्रह ८８",
    "१ इतिहास २९, लूका १२, हितोपदेश २１, भजनसंग्रह ८９",
    "२ इतिहास १, लूका १३, हितोपदेश २２, भजनसंग्रह ९０",
    "२ इतिहास २, लूका १४, हितोपदेश ২৩, भजनसंग्रह ९１",
    "२ इतिहास ३, लूका १५, हितोपदेश २४, भजनसंग्रह ९２",
    "२ इतिहास ४, लूका १६, हितोपदेश २५, भजनसंग्रह ९３",
    "२ इतिहास ५, लूका १७, हितोपदेश २６, भजनसंग्रह ९４",
    "२ इतिहास ६, लूका १८, हितोपदेश २７, भजनसंग्रह ९５",
    "२ इतिहास ७, लूका १९, हितोपदेश २８, भजनसंग्रह ९６",
    "२ इतिहास ८, लूका २०, हितोपदेश २९, भजनसंग्रह ९７",
    "२ इतिहास ९, लूका २１, हितोपदेश ३０, भजनसंग्रह ९８",
    "२ इतिहास १०, लूका २２, हितोपदेश ३１, भजनसंग्रह ९９",
    "२ इतिहास ११, लूका ২৩, भजनसंग्रह १०४, भजनसंग्रह १००",
    "२ इतिहास १२, लूका २४, भजनसंग्रह १०５, भजनसंग्रह १०१",
    "२ इतिहास १३, यूहन्ना १, भजनसंग्रह १०６, भजनसंग्रह १०２",
    "२ इतिहास १४, यूहन्ना २, भजनसंग्रह १०７, भजनसंग्रह १०३",
    "२ इतिहास १५, यूहन्ना ३, भजनसंग्रह १०８, भजनसंग्रह १०९",
    "२ इतिहास १६, यूहन्ना ४, भजनसंग्रह १１０, भजनसंग्रह ११１",
    "२ इतिहास १७, यूहन्ना ५, भजनसंग्रह १１２, भजनसंग्रह ११३",
    "२ इतिहास १८, यूहन्ना ६, भजनसंग्रह १１４, भजनसंग्रह ११５",
    "२ इतिहास १९, यूहन्ना ७, भजनसंग्रह १１６, भजनसंग्रह ११७",
    "२ इतिहास २०, यूहन्ना ८, भजनसंग्रह १１８, भजनसंग्रह ११९:१-३２",
    "२ इतिहास २１, यूहन्ना ९, भजनसंग्रह ११९:३३-６４, भजनसंग्रह ११९:६५-९६",
    "२ इतिहास २２, यूहन्ना १०, भजनसंग्रह ११९:९७-१２८, भजनसंग्रह ११९:१２९-१５２",
    "२ इतिहास ২৩, यूहन्ना ११, भजनसंग्रह ११९:१５３-१७６, भजनसंग्रह १२०",
    "२ इतिहास २४, यूहन्ना १२, भजनसंग्रह १२１, भजनसंग्रह १२２",
    "२ इतिहास २५, यूहन्ना १३, भजनसंग्रह १२３, भजनसंग्रह १२４",
    "२ इतिहास २６, यूहन्ना १४, भजनसंग्रह १२５, भजनसंग्रह १२６",
    "२ इतिहास २७, यूहन्ना १५, भजनसंग्रह १२７, भजनसंग्रह १२８",
    "२ इतिहास २८, यूहन्ना १६, भजनसंग्रह १२９, भजनसंग्रह १३０",
    "२ इतिहास २९, यूहन्ना १७, भजनसंग्रह १३１, भजनसंग्रह १३２",
    "२ इतिहास ३０, यूहन्ना १८, भजनसंग्रह १३３, भजनसंग्रह १३４",
    "२ इतिहास ३１, यूहन्ना १९, भजनसंग्रह १३５, भजनसंग्रह १३６",
    "२ इतिहास ३２, यूहन्ना २०, भजनसंग्रह १३７, भजनसंग्रह १३８",
    "२ इतिहास ३３, यूहन्ना २１, भजनसंग्रह १३９, भजनसंग्रह १४０",
    "२ इतिहास ३４, प्रेरित १, भजनसंग्रह १४１, भजनसंग्रह १४２",
    "२ इतिहास ३５, प्रेरित २, भजनसंग्रह १४３, भजनसंग्रह १४４",
    "२ इतिहास ३６, प्रेरित ३, भजनसंग्रह १४５, भजनसंग्रह १४６",
    "एज्रा १, प्रेरित ४, भजनसंग्रह १४７, भजनसंग्रह १४８",
    "एज्रा २, प्रेरित ५, भजनसंग्रह १४９, भजनसंग्रह १५０",
];


// --- Helper Functions ---
const formatDate = (timestamp: Timestamp | Date | undefined): string => {
    if (!timestamp) return '';
    const date = (timestamp as Timestamp).toDate ? (timestamp as Timestamp).toDate() : (timestamp as Date);
    return date.toLocaleDateString('ne-NP', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
    });
};
const formatTime = (timestamp: Timestamp | undefined): string => {
    if (!timestamp) return '';
    return timestamp.toDate().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
};
const formatRelativeTime = (timestamp: Timestamp | undefined): string => {
    if (!timestamp) return 'Just now';
    const now = new Date();
    const then = timestamp.toDate();
    const diffInSeconds = Math.floor((now.getTime() - then.getTime()) / 1000);

    if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
    if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
    return formatDate(timestamp);
};
function getAvatarInitial(name: string | undefined | null): string {
    if (!name) return 'L';
    const parts = name.split(' ');
    if (parts.length > 1 && parts[parts.length - 1]) {
        return `${parts[0][0]}${parts[parts.length - 1][0]}`.toUpperCase();
    }
    return name.substring(0, 1).toUpperCase();
}
const getEmbedUrl = (url: string): string | null => {
    if (!url) return null;
    try {
        // YouTube URLs (handles watch, embed, live, and youtu.be)
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|live\/)|youtu\.be\/)([\w-]{11})/;
        const youtubeMatch = url.match(youtubeRegex);
        if (youtubeMatch && youtubeMatch[1]) {
            const videoId = youtubeMatch[1];
            // Autoplay is often restricted by browsers and might require mute=1. playsinline is for iOS.
            return `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&playsinline=1`;
        }

        // Facebook URLs (handles various video URLs)
        const facebookRegex = /https?:\/\/(?:www\.|web\.)?facebook\.com\/(?:watch\/?\?v=|.+?\/videos\/|video\.php\?v=)/;
         if (facebookRegex.test(url)) {
             // Facebook embedder works best with the full original URL
            return `https://www.facebook.com/plugins/video.php?href=${encodeURIComponent(url)}&show_text=0&autoplay=1`;
        }
        
        return null; // Fallback for unsupported URLs
    } catch (error) {
        console.error("Error parsing stream URL:", url, error);
        return null;
    }
};


// --- React Components ---

const ErrorFallback: React.FC<{ error: Error }> = ({ error }) => (
    <div className="error-container">
        <img src={CHURCH.logo} alt="Church Logo" className="error-logo" />
        <h2>Oops! Something went wrong.</h2>
        <p>We're sorry, but the application encountered an unexpected error. Please try again later.</p>
        <pre>{error.message}</pre>
    </div>
);

const SplashScreen: React.FC = () => (
    <div className="splash-screen-container">
        <img src={CHURCH.logo} alt="Church Logo" className="splash-logo" />
        <div className="splash-spinner"></div>
    </div>
);

const Loading: React.FC<{ message?: string }> = ({ message = 'Loading...' }) => (
    <div className="loading-container">
        <div className="spinner"></div>
        <span>{message}</span>
    </div>
);

const Fab: React.FC<{ onClick: () => void; icon: string, 'aria-label': string }> = ({ onClick, icon, 'aria-label': ariaLabel }) => (
    <button className="fab" onClick={onClick} aria-label={ariaLabel}>
        <span className="material-symbols-outlined">{icon}</span>
    </button>
);

const Modal: React.FC<{ 
    isOpen: boolean; 
    onClose: () => void; 
    children: React.ReactNode;
    position?: 'center' | 'bottom';
}> = ({ isOpen, onClose, children, position = 'center' }) => {
    if (!isOpen) return null;

    return createPortal(
        <div className={`modal-backdrop ${position === 'bottom' ? 'modal-is-bottom' : ''}`} onClick={onClose}>
            <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                {children}
            </div>
        </div>,
        document.body
    );
};


const ImageUpload: React.FC<{
    selectedFile: File | null;
    setSelectedFile: (file: File | null) => void;
    currentImageUrl?: string | null;
    label?: string;
}> = ({ selectedFile, setSelectedFile, currentImageUrl, label = 'Add a photo' }) => {
    const [preview, setPreview] = useState<string | null>(currentImageUrl ?? null);
    const fileInputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (selectedFile) {
            const objectUrl = URL.createObjectURL(selectedFile);
            setPreview(objectUrl);
            return () => URL.revokeObjectURL(objectUrl);
        } else {
            setPreview(currentImageUrl ?? null);
        }
    }, [selectedFile, currentImageUrl]);

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0]) {
            setSelectedFile(e.target.files[0]);
        }
    };

    const handleRemoveImage = () => {
        setSelectedFile(null);
        setPreview(null);
        if (fileInputRef.current) {
            fileInputRef.current.value = "";
        }
    };
    
    return (
        <div className="image-upload-container">
            {preview ? (
                <div className="image-preview">
                    <img src={preview} alt="Preview" />
                    <button type="button" onClick={handleRemoveImage} aria-label="Remove image">
                         <span className="material-symbols-outlined">close</span>
                    </button>
                </div>
            ) : (
                <label htmlFor="image-upload" className="image-upload-label">
                     <span className="material-symbols-outlined">add_photo_alternate</span>
                    <span>{label}</span>
                    <input
                        id="image-upload"
                        type="file"
                        accept="image/*"
                        onChange={handleFileChange}
                        ref={fileInputRef}
                        style={{ display: 'none' }}
                    />
                </label>
            )}
        </div>
    );
};


const LoginPage: React.FC = () => {
    const { auth } = useFirebase();
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [name, setName] = useState('');
    const [isRegistering, setIsRegistering] = useState(false);

    const handleEmailAuth = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        setError('');
        try {
            if (isRegistering) {
                if (!name.trim()) { setError('Please enter your name.'); return; }
                const userCredential = await createUserWithEmailAndPassword(auth!, email, password);
                await updateProfile(userCredential.user, { displayName: name });
            } else {
                await signInWithEmailAndPassword(auth!, email, password);
            }
        } catch (err: any) {
            let friendlyMessage = err.message;
            if (err.code === 'auth/weak-password') {
                friendlyMessage = 'Password should be at least 6 characters.';
            } else if (err.code === 'auth/email-already-in-use') {
                friendlyMessage = 'This email is already in use. Please log in.';
            } else if (err.code === 'auth/invalid-credential') {
                 friendlyMessage = 'Incorrect email or password.';
            }
            setError(friendlyMessage);
        } finally {
            setLoading(false);
        }
    };

    const handleGoogleSignIn = async () => {
        if (!auth) return;
        setLoading(true);
        setError('');
        try {
            const provider = new GoogleAuthProvider();
            await signInWithPopup(auth, provider);
        } catch (err: any) {
            // Don't show an error if the user closes the sign-in popup.
            if (err.code !== 'auth/popup-closed-by-user') {
                setError(err.message);
            }
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="login-container">
            <div className="login-box">
                <img src={CHURCH.logo} alt="Church Logo" className="login-logo" />
                <h2>{isRegistering ? 'Create Account' : 'Welcome Back'}</h2>
                <p>{CHURCH.name}</p>

                <form onSubmit={handleEmailAuth}>
                    {isRegistering && (
                        <input type="text" className="login-input" placeholder="Full Name" value={name} onChange={(e) => setName(e.target.value)} required />
                    )}
                    <input type="email" className="login-input" placeholder="Email Address" value={email} onChange={(e) => setEmail(e.target.value)} required autoComplete="email" />
                    <input 
                        type="password" 
                        className="login-input" 
                        placeholder="6-digit PIN" 
                        value={password} 
                        onChange={(e) => setPassword(e.target.value)} 
                        required 
                        minLength={6}
                        maxLength={6} 
                        pattern="\d{6}" 
                        inputMode="numeric"
                        autoComplete={isRegistering ? "new-password" : "current-password"} 
                    />
                    <button type="submit" className="login-button" disabled={loading}>
                        {loading ? <div className="spinner"></div> : (isRegistering ? 'Sign Up' : 'Log In')}
                    </button>
                    <button type="button" onClick={() => { setIsRegistering(!isRegistering); setError(''); }} className="auth-toggle-link">
                        {isRegistering ? 'Already have an account? Log In' : "Don't have an account? Sign Up"}
                    </button>
                </form>

                <div className="login-divider"><span>OR</span></div>
                
                <button onClick={handleGoogleSignIn} className="google-signin-button" disabled={loading}>
                    <svg viewBox="0 0 48 48" width="24px" height="24px">
                        <path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path>
                        <path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path>
                        <path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path>
                        <path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path>
                        <path fill="none" d="M0 0h48v48H0z"></path>
                    </svg>
                    <span>Sign in with Google</span>
                </button>

                {error && <p className="login-error">{error}</p>}
            </div>
        </div>
    );
};

// --- Main App Pages ---
const WorshipPage: React.FC<{
    currentUser: User;
    liveService: WorshipService | null;
    pastServices: PastWorshipService[];
}> = ({ currentUser, liveService, pastServices }) => {
    const { db } = useFirebase();
    const [isOfferingModalOpen, setIsOfferingModalOpen] = useState(false);
    const [isAddPastWorshipModalOpen, setIsAddPastWorshipModalOpen] = useState(false);
    const [newPastService, setNewPastService] = useState({ title: '', youtubeUrl: '' });
    const [playingService, setPlayingService] = useState<PastWorshipService | null>(null);

    const embedUrl = liveService?.streamUrl ? getEmbedUrl(liveService.streamUrl) : null;
    const playingEmbedUrl = playingService?.youtubeUrl ? getEmbedUrl(playingService.youtubeUrl) : null;

    const handleAddPastService = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!db || !newPastService.title || !newPastService.youtubeUrl) return;
        
        try {
            await addDoc(collection(db, "pastWorshipServices"), {
                ...newPastService,
                createdAt: serverTimestamp()
            });
            setNewPastService({ title: '', youtubeUrl: '' });
            setIsAddPastWorshipModalOpen(false);
        } catch (error) {
            console.error("Error adding past worship service: ", error);
        }
    };

    const handleDeletePastService = async (serviceId: string) => {
        if (!db || !window.confirm("Are you sure you want to delete this past service?")) return;
        try {
            await deleteDoc(doc(db, "pastWorshipServices", serviceId));
        } catch (error) {
            console.error("Error deleting past service:", error);
        }
    }

    const getYoutubeThumbnail = (url: string) => {
        try {
            const videoIdMatch = url.match(/(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/);
            const videoId = videoIdMatch ? videoIdMatch[1] : null;
            return videoId ? `https://img.youtube.com/vi/${videoId}/hqdefault.jpg` : '/placeholder.jpg';
        } catch {
            return '/placeholder.jpg';
        }
    };

    return (
        <div className="page-content">
            <h2>आरधना</h2>
            {liveService && embedUrl ? (
                <div className="card live-worship-card">
                    <div className="live-badge">LIVE</div>
                    <div className="iframe-container">
                        <iframe
                            src={embedUrl || ''}
                            allow="autoplay; encrypted-media"
                            allowFullScreen={true}
                            title="Live Worship Stream"
                        ></iframe>
                    </div>
                    <h4>{liveService.title}</h4>
                </div>
            ) : (
                <div className="card no-live-service">
                    <span className="material-symbols-outlined">church</span>
                    <p>अहिले कुनै प्रत्यक्ष आरधना छैन।</p>
                </div>
            )}
             <div className="worship-actions">
                <button className="action-button" onClick={() => setIsOfferingModalOpen(true)}>
                    <span className="material-symbols-outlined">volunteer_activism</span>
                    अनलाइन भेटी
                </button>
            </div>
            <div className="past-worship-section">
                <h3>विगतका आरधना</h3>
                {currentUser.roles.includes('admin') && (
                    <button className="action-button add-past-worship-button" onClick={() => setIsAddPastWorshipModalOpen(true)}>
                        <span className="material-symbols-outlined">add</span> विगतका आरधना थप्नुहोस्।
                    </button>
                )}
                <div className="past-worship-list">
                    {pastServices.map(service => (
                        <div key={service.id} className="card past-service-card" onClick={() => setPlayingService(service)}>
                            <img 
                                src={getYoutubeThumbnail(service.youtubeUrl)}
                                alt={service.title}
                                className="past-service-thumbnail"
                                loading="lazy"
                            />
                            <p className="past-service-title">{service.title}</p>
                            {currentUser.roles.includes('admin') && (
                                <button
                                    className="delete-button past-service-delete-button"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDeletePastService(service.id);
                                    }}
                                    aria-label="Delete past service"
                                >
                                    <span className="material-symbols-outlined">delete</span>
                                </button>
                             )}
                        </div>
                    ))}
                </div>
            </div>

            <Modal isOpen={isOfferingModalOpen} onClose={() => setIsOfferingModalOpen(false)}>
                <div className="offering-modal-content">
                    <h3>Online Offering</h3>
                    <img src={CHURCH.offeringDetails.qrCodeUrl} alt="QR Code for offering" className="qr-code-img" />
                    <div className="offering-details">
                        <p><strong>Bank:</strong> {CHURCH.offeringDetails.bankName}</p>
                        <p><strong>Account Holder:</strong> {CHURCH.offeringDetails.accountHolder}</p>
                        <div className="account-number-container">
                            <p><strong>Account Number:</strong> {CHURCH.offeringDetails.accountNumber}</p>
                            <button
                                className="copy-button"
                                onClick={() => {
                                    navigator.clipboard.writeText(CHURCH.offeringDetails.accountNumber);
                                    alert('Account number copied!');
                                }}
                            >
                                <span className="material-symbols-outlined">content_copy</span> Copy
                            </button>
                        </div>
                    </div>
                </div>
            </Modal>
             <Modal isOpen={isAddPastWorshipModalOpen} onClose={() => setIsAddPastWorshipModalOpen(false)}>
                <form className="modal-form" onSubmit={handleAddPastService}>
                    <h3>Add Past Service</h3>
                    <input
                        type="text"
                        placeholder="Service Title"
                        value={newPastService.title}
                        onChange={(e) => setNewPastService({ ...newPastService, title: e.target.value })}
                        required
                    />
                    <input
                        type="url"
                        placeholder="YouTube URL"
                        value={newPastService.youtubeUrl}
                        onChange={(e) => setNewPastService({ ...newPastService, youtubeUrl: e.target.value })}
                        required
                    />
                    <div className="form-actions">
                        <button type="submit" className="action-button">Save</button>
                        <button type="button" className="action-button secondary" onClick={() => setIsAddPastWorshipModalOpen(false)}>Cancel</button>
                    </div>
                </form>
            </Modal>
            <Modal isOpen={!!playingService} onClose={() => setPlayingService(null)}>
                <div className="video-player-modal">
                     <button type="button" className="modal-close-button" onClick={() => setPlayingService(null)} aria-label="Close">
                         <span className="material-symbols-outlined">close</span>
                    </button>
                    {playingEmbedUrl ? (
                        <>
                            <h3>{playingService?.title}</h3>
                            <div className="iframe-container">
                                <iframe
                                    src={playingEmbedUrl}
                                    allow="autoplay; encrypted-media"
                                    allowFullScreen={true}
                                    title={playingService?.title}
                                ></iframe>
                            </div>
                            <a href={playingService?.youtubeUrl} target="_blank" rel="noopener noreferrer" className="view-on-youtube-link">
                                <span className="material-symbols-outlined">open_in_new</span>
                                View on YouTube
                            </a>
                        </>
                    ) : (
                        <p>Could not load video.</p>
                    )}
                </div>
            </Modal>
        </div>
    );
};


const BiblePage: React.FC = () => {
    const [verseOfTheDay, setVerseOfTheDay] = useState<Verse | null>(null);
    const dayOfMonth = new Date().getDate();

    useEffect(() => {
        const dayOfYear = Math.floor((new Date().getTime() - new Date(new Date().getFullYear(), 0, 0).getTime()) / (1000 * 60 * 60 * 24));
        setVerseOfTheDay(MOCK_VERSES_OF_THE_DAY[dayOfYear % MOCK_VERSES_OF_THE_DAY.length]);
    }, []);

    const getDayOfYear = () => {
         const now = new Date();
         const start = new Date(now.getFullYear(), 0, 0);
         const diff = (now.getTime() - start.getTime()) + ((start.getTimezoneOffset() - now.getTimezoneOffset()) * 60 * 1000);
         const oneDay = 1000 * 60 * 60 * 24;
         return Math.floor(diff / oneDay);
    };

    const todayReading = MCCHEYNE_READING_PLAN[getDayOfYear() -1] || MCCHEYNE_READING_PLAN[0];

    return (
        <div className="page-content">
            <h2>बाइबल</h2>
            <div className="list-container bible-card-list">
                {verseOfTheDay && (
                    <div className="card verse-card">
                        <p className="verse-text">"{verseOfTheDay.text}"</p>
                        <p className="verse-ref">- {verseOfTheDay.verse}</p>
                    </div>
                )}
                
                <div className="card bible-card">
                    <h3>आजको बाइबल पढ्ने योजना</h3>
                    <p>{todayReading}</p>
                </div>
                
                <div className="card bible-card">
                    <h3>आजको हितोपदेश</h3>
                    <p>आज {dayOfMonth} तारिख हो, हितोपदेश {dayOfMonth} अध्याय पढ्नुहोस्।</p>
                </div>
            </div>
        </div>
    );
};

const NewsPage: React.FC<{ 
    currentUser: User; 
    news: NewsItem[];
    setNews: React.Dispatch<React.SetStateAction<NewsItem[]>>
}> = ({ currentUser, news, setNews }) => {
    const { db, storage } = useFirebase();
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingNews, setEditingNews] = useState<NewsItem | null>(null);

    const handleOpenModal = (newsItem: NewsItem | null = null) => {
        setEditingNews(newsItem);
        setIsModalOpen(true);
    };

    const handleCloseModal = () => {
        setEditingNews(null);
        setIsModalOpen(false);
    };

    const handleSaveNews = (title: string, content: string, imageFile: File | null) => {
        if (!db || !storage || !currentUser) return;
    
        const tempId = `temp_${Date.now()}`;
        const optimisticNews: NewsItem = {
            id: tempId,
            tempId,
            title,
            content,
            authorId: currentUser.id,
            authorName: currentUser.name,
            createdAt: Timestamp.now(),
            status: 'uploading',
            localImagePreview: imageFile ? URL.createObjectURL(imageFile) : (editingNews?.image || undefined),
        };
    
        if (editingNews) {
            setNews(prev => prev.map(n => n.id === editingNews.id ? { ...optimisticNews, id: editingNews.id } : n));
        } else {
            setNews(prev => [optimisticNews, ...prev]);
        }
    
        const performSave = async () => {
            try {
                let finalImageUrl: string | null = editingNews?.image || null;
    
                if (imageFile) {
                    if (editingNews?.image) {
                        try {
                            await deleteObject(ref(storage, editingNews.image));
                        } catch (error) { console.warn("Could not delete old news image:", error); }
                    }
                    const imageRef = ref(storage, `news/${Date.now()}_${imageFile.name}`);
                    await uploadBytes(imageRef, imageFile);
                    finalImageUrl = await getDownloadURL(imageRef);
                }
    
                const payload = { title, content, authorId: currentUser.id, authorName: currentUser.name, image: finalImageUrl };
    
                if (editingNews) {
                    await updateDoc(doc(db, "news", editingNews.id), payload);
                } else {
                    await addDoc(collection(db, "news"), { ...payload, createdAt: serverTimestamp() });
                }
            } catch (error) {
                console.error("Failed to save news:", error);
                setNews(prev => prev.map(n => n.tempId === tempId ? { ...n, status: 'failed' } : n));
            }
        };
    
        performSave();
    };

    const handleDeleteNews = async (newsItem: NewsItem) => {
        if (!db || !storage) return;
        if (!window.confirm(`Are you sure you want to delete "${newsItem.title}"?`)) return;

        try {
            if (newsItem.image) {
                const imageRef = ref(storage, newsItem.image);
                await deleteObject(imageRef).catch(error => {
                    if (error.code !== 'storage/object-not-found') {
                        console.error("Error deleting image from storage:", error);
                    }
                });
            }
            await deleteDoc(doc(db, "news", newsItem.id));
        } catch (error) {
            console.error("Error deleting news item: ", error);
        }
    };

    const canPostNews = currentUser.roles.includes('admin') || currentUser.roles.includes('news_contributor');
    const canManagePost = (item: NewsItem) => currentUser.id === item.authorId || currentUser.roles.includes('admin');

    return (
        <div className="page-content">
            <h2>सुचना</h2>
            <div className="list-container">
                {news.map(item => (
                    <div key={item.tempId || item.id} className="card news-item">
                         {item.status && (
                            <div className="upload-status-overlay">
                                {item.status === 'uploading' ? <div className="spinner"></div> : <span>&#x26A0;</span>}
                            </div>
                        )}
                        {(item.localImagePreview || item.image) && <img src={item.localImagePreview || item.image || ''} alt={item.title} className="news-image" loading="lazy" />}
                        <div className="news-content">
                            <div className="news-header">
                                <h3>{item.title}</h3>
                                {canManagePost(item) && (
                                    <div className="item-actions-header">
                                        <button onClick={() => handleOpenModal(item)} className="edit-button" aria-label="Edit news">
                                            <span className="material-symbols-outlined">edit</span>
                                        </button>
                                        <button onClick={() => handleDeleteNews(item)} className="delete-button" aria-label="Delete news">
                                            <span className="material-symbols-outlined">delete</span>
                                        </button>
                                    </div>
                                )}
                            </div>
                            <p className="news-meta">By {item.authorName} on {formatDate(item.createdAt)}</p>
                            <p>{item.content}</p>
                        </div>
                    </div>
                ))}
            </div>
            {canPostNews && <Fab onClick={() => handleOpenModal()} icon="feed" aria-label="Add news" />}

            <NewsFormModal
                isOpen={isModalOpen}
                onClose={handleCloseModal}
                onSave={handleSaveNews}
                newsItem={editingNews}
            />
        </div>
    );
};

const NewsFormModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    onSave: (title: string, content: string, imageFile: File | null) => void;
    newsItem: NewsItem | null;
}> = ({ isOpen, onClose, onSave, newsItem }) => {
    const [title, setTitle] = useState('');
    const [content, setContent] = useState('');
    const [imageFile, setImageFile] = useState<File | null>(null);
    
    useEffect(() => {
        if (isOpen) {
            setTitle(newsItem?.title || '');
            setContent(newsItem?.content || '');
            setImageFile(null); // Reset file input on open
        }
    }, [isOpen, newsItem]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave(title, content, imageFile);
        onClose();
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <form className="modal-form" onSubmit={handleSubmit}>
                <button type="button" className="modal-close-button" onClick={onClose} aria-label="Close">
                     <span className="material-symbols-outlined">close</span>
                </button>
                <h3>{newsItem ? 'सुचना सम्पादन गर्नुहोस्' : 'सुचना थप्नुहोस्।'}</h3>
                <input
                    type="text"
                    placeholder="शीर्षक"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    required
                />
                <textarea
                    placeholder="सामग्री"
                    rows={5}
                    value={content}
                    onChange={(e) => setContent(e.target.value)}
                    required
                ></textarea>
                <ImageUpload 
                    selectedFile={imageFile} 
                    setSelectedFile={setImageFile} 
                    currentImageUrl={newsItem?.image}
                    label="फोटो थप्नुहोस्।(यदि तपाईं चाहनुहुन्छ भने)"
                />

                <div className="form-actions">
                    <button type="submit" className="action-button">
                        सेभ गर्नुहोस्
                    </button>
                </div>
            </form>
        </Modal>
    );
};

const PodcastsPage: React.FC<{
    currentUser: User, 
    podcasts: Podcast[],
    setPodcasts: React.Dispatch<React.SetStateAction<Podcast[]>>
}> = ({currentUser, podcasts, setPodcasts}) => {
    const { db, storage } = useFirebase();
    const [isModalOpen, setIsModalOpen] = useState(false);

    const handleSavePodcast = (title: string, audioFile: File) => {
        if (!db || !storage || !currentUser) return;
    
        const tempId = `temp_${Date.now()}`;
        const optimisticPodcast: Podcast = {
            id: tempId,
            tempId,
            title,
            authorId: currentUser.id,
            authorName: currentUser.name,
            audioUrl: '', // Will be filled later
            createdAt: Timestamp.now(),
            status: 'uploading',
            localAudioUrl: URL.createObjectURL(audioFile),
        };
    
        setPodcasts(prev => [optimisticPodcast, ...prev]);
    
        const performSave = async () => {
            try {
                const audioRef = ref(storage, `podcasts/${Date.now()}_${audioFile.name}`);
                await uploadBytes(audioRef, audioFile);
                const audioUrl = await getDownloadURL(audioRef);
    
                await addDoc(collection(db, "podcasts"), {
                    title,
                    audioUrl,
                    authorId: currentUser.id,
                    authorName: currentUser.name,
                    createdAt: serverTimestamp(),
                });
            } catch (error) {
                console.error("Failed to save podcast:", error);
                setPodcasts(prev => prev.map(p => p.tempId === tempId ? { ...p, status: 'failed' } : p));
            }
        };
    
        performSave();
    };
    
    const handleDeletePodcast = async (podcast: Podcast) => {
        if(!db || !storage) return;
        if (!window.confirm(`Are you sure you want to delete "${podcast.title}"?`)) return;

        try {
            const audioRef = ref(storage, podcast.audioUrl);
            await deleteObject(audioRef);
            await deleteDoc(doc(db, "podcasts", podcast.id));
        } catch (error) {
            console.error("Error deleting podcast: ", error);
        }
    };

    const canPostPodcast = currentUser.roles.includes('admin') || currentUser.roles.includes('podcast_contributor');
    const canManagePodcast = (podcast: Podcast) => currentUser.id === podcast.authorId || currentUser.roles.includes('admin');

    return (
        <div className="page-content">
            <h2>Podcasts</h2>
            <div className="list-container">
                {podcasts.map(podcast => (
                    <div key={podcast.tempId || podcast.id} className="card podcast-item">
                        {podcast.status && (
                            <div className="upload-status-overlay">
                                {podcast.status === 'uploading' ? <div className="spinner"></div> : <span>&#x26A0;</span>}
                            </div>
                        )}
                        <div className="podcast-info">
                            <div>
                                <p className="podcast-title">{podcast.title}</p>
                                <p className="podcast-author">By {podcast.authorName} - {formatDate(podcast.createdAt)}</p>
                            </div>
                            {canManagePodcast(podcast) && (
                                <button onClick={() => handleDeletePodcast(podcast)} className="delete-button" aria-label="Delete podcast">
                                    <span className="material-symbols-outlined">delete</span>
                                </button>
                            )}
                        </div>
                        <audio controls className="podcast-player" src={podcast.localAudioUrl || podcast.audioUrl}>
                            Your browser does not support the audio element.
                        </audio>
                    </div>
                ))}
            </div>
            {canPostPodcast && <Fab onClick={() => setIsModalOpen(true)} icon="podcasts" aria-label="Add podcast" />}

            <AddPodcastModal
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                onSave={handleSavePodcast}
            />
        </div>
    );
};

const AddPodcastModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    onSave: (title: string, audioFile: File) => void;
}> = ({ isOpen, onClose, onSave }) => {
    const [title, setTitle] = useState('');
    const [audioFile, setAudioFile] = useState<File | null>(null);
    const [activeTab, setActiveTab] = useState<'upload' | 'record'>('upload');
    
    // Recording state
    const [isRecording, setIsRecording] = useState(false);
    const [recordingTime, setRecordingTime] = useState(0);
    const [recordedBlob, setRecordedBlob] = useState<Blob | null>(null);
    const [recordedAudioUrl, setRecordedAudioUrl] = useState<string | null>(null);
    const mediaRecorderRef = useRef<MediaRecorder | null>(null);
    const timerIntervalRef = useRef<number | null>(null);

    useEffect(() => {
        if (recordedBlob) {
            const url = URL.createObjectURL(recordedBlob);
            setRecordedAudioUrl(url);
            return () => URL.revokeObjectURL(url); // Cleanup on component unmount or when blob changes
        }
        setRecordedAudioUrl(null);
    }, [recordedBlob]);

    const handleStartRecording = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorderRef.current = new MediaRecorder(stream);
            const chunks: Blob[] = [];
            
            mediaRecorderRef.current.ondataavailable = (e: BlobEvent) => {
                chunks.push(e.data);
            };
            
            mediaRecorderRef.current.onstop = () => {
                const blob = new window.Blob(chunks, { type: 'audio/webm' });
                setRecordedBlob(blob);
                const audioFile = new window.File([blob], "recording.webm", { type: 'audio/webm' });
                setAudioFile(audioFile);
                stream.getTracks().forEach(track => track.stop());
            };
            
            mediaRecorderRef.current.start();
            setIsRecording(true);
            timerIntervalRef.current = window.setInterval(() => {
                setRecordingTime(prev => prev + 1);
            }, 1000);
        } catch (error) {
            console.error("Error starting recording:", error);
            alert("마이크를 सुरु गर्न सकिएन। कृपया ब्राउजर वा फोन सेटिङहरूमा यो साइटको लागि माइक अनुमति जाँच गर्नुहोस्।");
        }
    };
    
    const handleStopRecording = () => {
        if (mediaRecorderRef.current) {
            mediaRecorderRef.current.stop();
            setIsRecording(false);
            if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
            setRecordingTime(0);
        }
    };

    const handleResetRecording = () => {
        setRecordedBlob(null);
        setAudioFile(null);
        setRecordingTime(0);
    }
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (!audioFile || !title.trim()) {
            alert("Please provide a title and select or record an audio file.");
            return;
        }
        onSave(title, audioFile);
        setTitle('');
        setAudioFile(null);
        handleResetRecording();
        onClose();
    };

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = (seconds % 60).toString().padStart(2, '0');
        return `${mins}:${secs}`;
    };

    return (
         <Modal isOpen={isOpen} onClose={onClose}>
            <form className="modal-form" onSubmit={handleSubmit}>
                <button type="button" className="modal-close-button" onClick={onClose} aria-label="Close">
                     <span className="material-symbols-outlined">close</span>
                </button>
                <h3>Add Podcast</h3>

                <div className="add-podcast-tabs">
                    <button type="button" className={activeTab === 'upload' ? 'active' : ''} onClick={() => setActiveTab('upload')}>Upload</button>
                    <button type="button" className={activeTab === 'record' ? 'active' : ''} onClick={() => setActiveTab('record')}>Record</button>
                </div>

                <input
                    type="text"
                    placeholder="Podcast Title"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    required
                />
                
                {activeTab === 'upload' && (
                     <label htmlFor="audio-upload" className="action-button secondary custom-file-input">
                        <span className="material-symbols-outlined">upload_file</span>
                        <span>{audioFile ? audioFile.name : 'Choose Audio File'}</span>
                         <input
                            id="audio-upload"
                            type="file"
                            accept="audio/*"
                            onChange={(e) => e.target.files && setAudioFile(e.target.files[0])}
                            style={{ display: 'none' }}
                        />
                    </label>
                )}

                {activeTab === 'record' && (
                    <div className="record-section">
                        <p className="permission-helper-text">
                           녹음을 시작하려면 마이크 권한이 필요합니다. '녹음 시작' 버튼을 누르면 권한을 요청하는 팝업이 나타납니다.
                        </p>
                        {!recordedBlob ? (
                             <button type="button" className={`record-button ${isRecording ? 'recording' : ''}`} onClick={isRecording ? handleStopRecording : handleStartRecording}>
                                <span className="material-symbols-outlined">{isRecording ? 'stop_circle' : 'mic'}</span>
                                {isRecording ? <span className="timer">{formatTime(recordingTime)}</span> : 'Start Recording'}
                            </button>
                        ) : (
                             <div className="recording-preview">
                                <p>Recording complete:</p>
                                {recordedAudioUrl && <audio controls src={recordedAudioUrl}></audio>}
                                <button type="button" className="action-button secondary" onClick={handleResetRecording}>Record Again</button>
                            </div>
                        )}
                    </div>
                )}
                
                <div className="form-actions">
                    <button type="submit" className="action-button" disabled={!audioFile}>
                        Save Podcast
                    </button>
                </div>
            </form>
        </Modal>
    );
};


const PrayerPage: React.FC<{ 
    currentUser: User; 
    requests: PrayerRequest[];
    setRequests: React.Dispatch<React.SetStateAction<PrayerRequest[]>>;
}> = ({ currentUser, requests, setRequests }) => {
    const { db, storage } = useFirebase();
    const [selectedRequest, setSelectedRequest] = useState<PrayerRequest | null>(null);
    const [isAddModalOpen, setIsAddModalOpen] = useState(false);
    const [editingRequest, setEditingRequest] = useState<PrayerRequest | null>(null);

    const handleTogglePrayed = async (request: PrayerRequest) => {
        if (!db || request.status) return; // Don't interact with uploading items
        const requestRef = doc(db, "prayerRequests", request.id);
        const alreadyPrayed = request.prayedBy.includes(currentUser.id);

        await updateDoc(requestRef, {
            prayedBy: alreadyPrayed ? arrayRemove(currentUser.id) : arrayUnion(currentUser.id)
        });
    };

    const handleOpenAddModal = (request: PrayerRequest | null = null) => {
        setEditingRequest(request);
        setIsAddModalOpen(true);
    };

    const handleCloseAddModal = () => {
        setIsAddModalOpen(false);
        setEditingRequest(null);
    };
    
    const handleSavePrayerRequest = (title: string, content: string, imageFile: File | null) => {
        if (!db || !storage || !currentUser) return;
    
        const tempId = `temp_${Date.now()}`;
        const optimisticRequest: PrayerRequest = {
            id: tempId,
            tempId,
            title,
            content,
            authorId: currentUser.id,
            authorName: currentUser.name,
            prayedBy: editingRequest?.prayedBy || [],
            commentCount: editingRequest?.commentCount || 0,
            createdAt: Timestamp.now(),
            status: 'uploading',
            localImagePreview: imageFile ? URL.createObjectURL(imageFile) : (editingRequest?.image || undefined),
        };
    
        if (editingRequest) {
            setRequests(prev => prev.map(r => r.id === editingRequest.id ? { ...optimisticRequest, id: editingRequest.id } : r));
        } else {
            setRequests(prev => [optimisticRequest, ...prev]);
        }
    
        const performSave = async () => {
            try {
                let finalImageUrl: string | null = editingRequest?.image || null;
    
                if (imageFile) {
                    if (editingRequest?.image) {
                        try { await deleteObject(ref(storage, editingRequest.image)); } catch (e) { console.warn("Old image delete failed", e); }
                    }
                    const imageRef = ref(storage, `prayers/${Date.now()}_${imageFile.name}`);
                    await uploadBytes(imageRef, imageFile);
                    finalImageUrl = await getDownloadURL(imageRef);
                }
    
                const payload = { title, content, authorId: currentUser.id, authorName: currentUser.name, image: finalImageUrl };
    
                if (editingRequest) {
                    await updateDoc(doc(db, "prayerRequests", editingRequest.id), payload);
                } else {
                    await addDoc(collection(db, "prayerRequests"), { ...payload, prayedBy: [], createdAt: serverTimestamp() });
                }
            } catch (error) {
                console.error("Failed to save prayer request:", error);
                setRequests(prev => prev.map(r => r.tempId === tempId ? { ...r, status: 'failed' } : r));
            }
        };
    
        performSave();
    };

    const handleDeleteRequest = async (request: PrayerRequest) => {
        if (!db || !storage || request.status) return;
        if (!window.confirm("Are you sure you want to delete this prayer request?")) return;

        try {
            if (request.image) {
                const imageRef = ref(storage, request.image);
                await deleteObject(imageRef).catch(e => console.error("Image delete failed", e));
            }
            await deleteDoc(doc(db, "prayerRequests", request.id));
            setSelectedRequest(null);
        } catch (error) {
            console.error("Error deleting prayer request: ", error);
        }
    };
    
    const handleShowDetails = (req: PrayerRequest) => {
        if(req.status) return; // Don't open details for uploading items
        setEditingRequest(req); // Set for potential edit/delete
        setSelectedRequest(req);
    };

    const canManageRequest = (req: PrayerRequest) => currentUser.id === req.authorId || currentUser.roles.includes('admin');

    return (
        <div className="page-content">
            <h2>प्रार्थना</h2>
            <div className="list-container">
                {requests.map(req => (
                    <div key={req.tempId || req.id} className="card prayer-item" onClick={() => handleShowDetails(req)}>
                        {req.status && (
                            <div className="upload-status-overlay">
                                {req.status === 'uploading' ? <div className="spinner"></div> : <span>&#x26A0;</span>}
                            </div>
                        )}
                        {(req.localImagePreview || req.image) && <img src={req.localImagePreview || req.image || ''} alt={req.title} className="prayer-image" loading="lazy" />}
                        <h4>{req.title}</h4>
                        <p className="prayer-content">{req.content}</p>
                        <div className="prayer-meta">
                            <span>By {req.authorName} - {formatRelativeTime(req.createdAt)}</span>
                            <div className="prayer-actions">
                                <button
                                    className={`prayer-action-button ${req.prayedBy.includes(currentUser.id) ? 'prayed' : ''}`}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleTogglePrayed(req);
                                    }}
                                >
                                    <span className="material-symbols-outlined">volunteer_activism</span>
                                    <span>{req.prayedBy.length}</span>
                                </button>
                                <div className="prayer-action-button">
                                    <span className="material-symbols-outlined">comment</span>
                                    <span>{req.commentCount || 0}</span>
                                </div>
                            </div>
                        </div>
                        {canManageRequest(req) && !req.status && (
                            <div className="item-actions-footer">
                                <button onClick={(e) => { e.stopPropagation(); handleOpenAddModal(req); }} className="edit-button" aria-label="Edit prayer request">
                                    <span className="material-symbols-outlined">edit</span>
                                </button>
                                <button onClick={(e) => { e.stopPropagation(); handleDeleteRequest(req); }} className="delete-button" aria-label="Delete prayer request">
                                    <span className="material-symbols-outlined">delete</span>
                                </button>
                            </div>
                        )}
                    </div>
                ))}
            </div>
            <Fab onClick={() => handleOpenAddModal()} icon="volunteer_activism" aria-label="Add prayer request" />

            {selectedRequest && (
                <PrayerDetailsModal
                    request={selectedRequest}
                    onClose={() => setSelectedRequest(null)}
                    currentUser={currentUser}
                />
            )}
            <PrayerFormModal
                isOpen={isAddModalOpen}
                onClose={handleCloseAddModal}
                onSave={handleSavePrayerRequest}
                request={editingRequest}
            />
        </div>
    );
};


const PrayerFormModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    onSave: (title: string, content: string, imageFile: File | null) => void;
    request: PrayerRequest | null;
}> = ({ isOpen, onClose, onSave, request }) => {
    const [title, setTitle] = useState('');
    const [content, setContent] = useState('');
    const [imageFile, setImageFile] = useState<File | null>(null);

    useEffect(() => {
        if (isOpen) {
            setTitle(request?.title || '');
            setContent(request?.content || '');
            setImageFile(null); // Reset file input
        }
    }, [isOpen, request]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave(title, content, imageFile);
        onClose();
    };
    
    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <form className="modal-form" onSubmit={handleSubmit}>
                <button type="button" className="modal-close-button" onClick={onClose} aria-label="Close">
                     <span className="material-symbols-outlined">close</span>
                </button>
                <h3>{request ? 'अनुरोध सम्पादन गर्नुहोस्' : 'प्रार्थना अनुरोध'}</h3>
                <input
                    type="text"
                    placeholder="शीर्षक"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    required
                />
                <textarea
                    placeholder="हामीले तपाईंको लागि के प्रार्थना गर्नुपर्छ?"
                    rows={5}
                    value={content}
                    onChange={(e) => setContent(e.target.value)}
                    required
                ></textarea>
                <ImageUpload 
                    selectedFile={imageFile} 
                    setSelectedFile={setImageFile} 
                    currentImageUrl={request?.image}
                    label="फोटो थप्नुहोस्।(यदि तपाईं चाहनुहुन्छ भने)" 
                />
                <button type="submit" className="action-button">
                    अनुरोध पठाउनुहोस्।
                </button>
            </form>
        </Modal>
    );
};

const PrayerDetailsModal: React.FC<{
    request: PrayerRequest;
    onClose: () => void;
    currentUser: User;
}> = ({ request, onClose, currentUser }) => {
    const { db } = useFirebase();
    const [newComment, setNewComment] = useState('');
    const [comments, setComments] = useState<Comment[]>([]);
    const [isCommenting, setIsCommenting] = useState(false);

    useEffect(() => {
        if (!db || !request?.id) return;
        const commentsCol = collection(db, "prayerRequests", request.id, "comments");
        const q = query(commentsCol, orderBy("createdAt", "asc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedComments = snapshot.docs.map(doc => ({id: doc.id, ...doc.data() } as Comment));
            setComments(fetchedComments);
        });
        return () => unsubscribe();
    }, [db, request?.id]);


    const handleAddComment = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!db || !newComment.trim() || !request || !currentUser || isCommenting) return;

        setIsCommenting(true);
        try {
            const prayerRequestRef = doc(db, "prayerRequests", request.id);
            const commentsCollectionRef = collection(prayerRequestRef, "comments");
            
            await Promise.all([
                addDoc(commentsCollectionRef, {
                    authorId: currentUser.id,
                    authorName: currentUser.name || "Unknown User",
                    authorAvatar: currentUser.avatar || '',
                    content: newComment,
                    createdAt: serverTimestamp(),
                }),
                updateDoc(prayerRequestRef, {
                    commentCount: increment(1)
                })
            ]);
            
            setNewComment('');
            onClose();
        } catch (error) {
            console.error("Error adding comment: ", error);
            alert("Failed to post comment.");
        } finally {
            setIsCommenting(false);
        }
    };
    
     if (!request) return null;

    return (
        <Modal isOpen={true} onClose={onClose} position="bottom">
            <div>
                 <button type="button" className="modal-close-button" onClick={onClose} aria-label="Close">
                     <span className="material-symbols-outlined">close</span>
                </button>
                <div className="prayer-details-header">
                    <h3>{request.title}</h3>
                </div>
                <p className="prayer-author">By {request.authorName} - {formatDate(request.createdAt)}</p>
                {request.image && <img src={request.image} alt={request.title} style={{ width: '100%', borderRadius: '8px', marginBottom: '16px' }} />}
                <p className="prayer-main-content">{request.content}</p>

                <div className="prayer-comments-section">
                    <h4>Comments ({comments.length})</h4>
                    <div className="prayer-comment-list">
                        {comments.length > 0 ? (
                            comments.map((comment) => (
                                <div key={comment.id} className="comment-item">
                                    <strong>{comment.authorName}</strong>
                                    <p>{comment.content}</p>
                                    <span className="comment-timestamp">{formatRelativeTime(comment.createdAt)}</span>
                                </div>
                            ))
                        ) : (
                            <p className="no-comments">No comments yet.</p>
                        )}
                    </div>
                    <form className="comment-form" onSubmit={handleAddComment}>
                        <input
                            type="text"
                            placeholder="Add a comment..."
                            value={newComment}
                            onChange={(e) => setNewComment(e.target.value)}
                        />
                        <button type="submit" aria-label="Send comment" disabled={isCommenting || !newComment.trim()}>
                            {isCommenting ? <div className="spinner-small"></div> : <span className="material-symbols-outlined">send</span>}
                        </button>
                    </form>
                </div>
            </div>
        </Modal>
    );
};


const ChatListPage: React.FC<{
    currentUser: User;
    usersMap: Map<string, User>;
    chats: Chat[];
    onChatSelect: (chat: Chat) => void;
    onCreateChat: (participants: User[]) => Promise<string | null>;
}> = ({ currentUser, usersMap, chats, onChatSelect, onCreateChat }) => {
    const { db, storage } = useFirebase();
    const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
    const [chatToDelete, setChatToDelete] = useState<Chat | null>(null);
    const users = Array.from(usersMap.values());

    const getOtherParticipant = (chat: Chat, currentUserId: string) => {
        const otherId = chat.participantIds.find(id => id !== currentUserId);

        if (chat.participantIds.length > 2) {
            const names = chat.participantIds
                .filter(id => id !== currentUserId)
                .map(id => usersMap.get(id)?.name.split(' ')[0] || '')
                .filter(name => name)
                .slice(0, 2)
                .join(', ');
            return { name: names + (chat.participantIds.length > 3 ? '...' : ''), avatar: '' };
        }
        
        if (otherId) {
            if (chat.participants && chat.participants[otherId] && chat.participants[otherId].name) {
                return chat.participants[otherId];
            }
            const userFromMap = usersMap.get(otherId);
            if (userFromMap) {
                return { name: userFromMap.name, avatar: userFromMap.avatar };
            }
        }
        
        return { name: "Unknown User", avatar: '' };
    };

    const handleCreateChat = async (selectedUsers: User[]) => {
        const newChatId = await onCreateChat(selectedUsers);
        if (newChatId) {
            const chatDoc = await getDoc(doc(db!, "chats", newChatId));
            if(chatDoc.exists()) {
                onChatSelect({ id: chatDoc.id, ...chatDoc.data() } as Chat);
            }
        }
        setIsCreateModalOpen(false);
    };
    
    const handleDeleteChat = async (chat: Chat) => {
        if (!db || !storage) return;
    
        try {
            const messagesQuery = query(collection(db, "chats", chat.id, "messages"));
            const messagesSnapshot = await getDocs(messagesQuery);
            
            const deletePromises: Promise<void>[] = [];
            
            messagesSnapshot.forEach(messageDoc => {
                const message = messageDoc.data() as Message;
                if (message.media) {
                    message.media.forEach(mediaItem => {
                        if (mediaItem.path) {
                            deletePromises.push(deleteObject(ref(storage, mediaItem.path)).catch(err => console.error("Failed to delete media:", err)));
                        }
                    });
                }
                deletePromises.push(deleteDoc(doc(db, "chats", chat.id, "messages", messageDoc.id)));
            });
    
            await Promise.all(deletePromises);
    
            await deleteDoc(doc(db, "chats", chat.id));
    
            setChatToDelete(null);
        } catch (error) {
            console.error("Error deleting chat:", error);
            alert("Failed to delete chat. Please try again.");
            setChatToDelete(null);
        }
    };

    const getLastMessagePreview = (chat: Chat) => {
        if (!chat.lastMessage) return "No messages yet";
        const content = chat.lastMessage.content;
        if (content.startsWith('📷')) return '📷 Photo(s)';
        if (content.startsWith('📹')) return '📹 Video(s)';
        return content;
    };

    return (
        <div className="page-content">
            <h2>संगतिहरु</h2>
            <div className="list-container">
                 {chats.length > 0 ? (
                    chats.map(chat => {
                        const otherParticipant = getOtherParticipant(chat, currentUser.id);
                        const isUnread = chat.lastRead && chat.lastMessage && chat.lastMessage.senderId !== currentUser.id && (!chat.lastRead[currentUser.id] || chat.lastRead[currentUser.id] < chat.lastMessage.createdAt);
                        return (
                            <div key={chat.id} className="list-item chat-item">
                                <div className="chat-content-wrapper" onClick={() => onChatSelect(chat)}>
                                    <div className="chat-avatar">{getAvatarInitial(otherParticipant.name)}</div>
                                    <div className="chat-info">
                                        <span className="chat-name">{otherParticipant.name}</span>
                                        <p className="chat-last-message">{getLastMessagePreview(chat)}</p>
                                    </div>
                                    <div className="chat-meta">
                                        <span>{chat.lastActivity ? formatRelativeTime(chat.lastActivity) : ''}</span>
                                        {isUnread && <div className="unread-dot"></div>}
                                    </div>
                                </div>
                                <button className="chat-delete-button" onClick={() => setChatToDelete(chat)} aria-label={`Delete chat with ${otherParticipant.name}`}>
                                    <span className="material-symbols-outlined">delete</span>
                                </button>
                            </div>
                        )
                    })
                 ) : (
                    <div className="card" style={{ textAlign: 'center', padding: '32px', color: '#666' }}>
                        <span className="material-symbols-outlined" style={{ fontSize: '48px', color: '#ccc', marginBottom: '16px' }}>chat_bubble</span>
                        <p>No conversations yet.</p>
                        <p style={{ fontSize: 'var(--font-size-sm)', marginTop: '8px' }}>Tap the button below to start a new chat.</p>
                    </div>
                 )}
            </div>
            <Fab onClick={() => setIsCreateModalOpen(true)} icon="groups" aria-label="New chat" />

            <CreateChatModal
                isOpen={isCreateModalOpen}
                onClose={() => setIsCreateModalOpen(false)}
                currentUser={currentUser}
                users={users}
                onCreate={handleCreateChat}
            />

            <Modal isOpen={!!chatToDelete} onClose={() => setChatToDelete(null)}>
                <div className="delete-confirmation">
                    <h3>Delete Conversation?</h3>
                    <p>This will permanently delete this conversation for everyone. This action cannot be undone.</p>
                    <div className="form-actions">
                        <button className="action-button secondary" onClick={() => setChatToDelete(null)}>Cancel</button>
                        <button className="action-button danger" onClick={() => chatToDelete && handleDeleteChat(chatToDelete)}>Delete</button>
                    </div>
                </div>
            </Modal>
        </div>
    );
};

const CreateChatModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    currentUser: User;
    users: User[];
    onCreate: (participants: User[]) => void;
}> = ({ isOpen, onClose, currentUser, users, onCreate }) => {
    const [selectedUsers, setSelectedUsers] = useState<User[]>([]);

    const uniqueUsers = useMemo(() => {
        const userMap = new Map<string, User>();
        users.forEach(user => {
            if (user.email && !userMap.has(user.email)) {
                userMap.set(user.email, user);
            } else if (!user.email) {
                if (!userMap.has(user.id)) {
                    userMap.set(user.id, user);
                }
            }
        });
        return Array.from(userMap.values());
    }, [users]);


    const handleToggleUser = (user: User) => {
        setSelectedUsers(prev =>
            prev.some(u => u.id === user.id)
                ? prev.filter(u => u.id !== user.id)
                : [...prev, user]
        );
    };

    const handleCreate = () => {
        if(selectedUsers.length > 0) {
            onCreate(selectedUsers);
            setSelectedUsers([]);
        }
    };
    
    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <div className="create-chat-modal">
                <h3>Start a conversation</h3>
                <div className="user-list">
                    {uniqueUsers.filter(u => u.id !== currentUser.id).map(user => {
                        const isSelected = selectedUsers.some(su => su.id === user.id);
                        return (
                            <div key={user.id} className={`list-item user-list-item selectable ${isSelected ? 'selected' : ''}`} onClick={() => handleToggleUser(user)}>
                                <div className="chat-avatar">{getAvatarInitial(user.name)}</div>
                                <div className="chat-info">
                                    <span className="chat-name">{user.name}</span>
                                </div>
                                <div className="checkbox">
                                    {isSelected && <span className="material-symbols-outlined">check</span>}
                                </div>
                            </div>
                        )
                    })}
                </div>
                <button
                    className="action-button"
                    style={{ marginTop: '16px' }}
                    onClick={handleCreate}
                    disabled={selectedUsers.length === 0}
                >
                    Start Chat ({selectedUsers.length})
                </button>
            </div>
        </Modal>
    );
};

const ConversationPage: React.FC<{
    chat: Chat;
    currentUser: User;
    onBack: () => void;
}> = ({ chat, currentUser, onBack }) => {
    const { db, storage } = useFirebase();
    const [messages, setMessages] = useState<Message[]>([]);
    const [newMessage, setNewMessage] = useState('');
    const [mediaPreviews, setMediaPreviews] = useState<{ url: string; file: File; type: 'image' | 'video' }[]>([]);
    const [currentChat, setCurrentChat] = useState<Chat | null>(chat);
    const [loading, setLoading] = useState(true);
    const [deletingMessage, setDeletingMessage] = useState<Message | null>(null);
    const [viewingMedia, setViewingMedia] = useState<{ media: MediaItem[]; startIndex: number } | null>(null);

    const messagesEndRef = useRef<HTMLDivElement>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (!db || !chat?.id) return;
        setLoading(true);
        const chatRef = doc(db, 'chats', chat.id);
        const unsubscribeChat = onSnapshot(chatRef, (doc) => {
            if (doc.exists()) {
                setCurrentChat({ id: doc.id, ...doc.data() } as Chat);
            } else { onBack(); }
        });

        const messagesQuery = query(collection(db, "chats", chat.id, "messages"), orderBy("createdAt", "asc"));
        const unsubscribeMessages = onSnapshot(messagesQuery, (snapshot) => {
            const fetchedMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Message));
            setMessages(fetchedMessages);
            setLoading(false);
        });

        updateDoc(chatRef, { [`lastRead.${currentUser.id}`]: Timestamp.now() }).catch(err => console.error("Error updating lastRead:", err));
        
        return () => { unsubscribeChat(); unsubscribeMessages(); }
    }, [db, chat?.id, onBack, currentUser.id]);

    useEffect(() => {
        if (!loading) { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }
    }, [messages, loading]);

    const handleSendMessage = async () => {
        const textContent = newMessage.trim();
        const mediaFiles = [...mediaPreviews];
        if (!db || !storage || !currentChat || (!textContent && mediaFiles.length === 0)) return;

        setNewMessage('');
        setMediaPreviews([]);
        
        const tempId = `temp_${Date.now()}`;
        const optimisticMessage: Message = {
            id: tempId, tempId, senderId: currentUser.id, createdAt: Timestamp.now(), status: 'uploading',
            ...(textContent && { content: textContent }),
            ...(mediaFiles.length > 0 && {
                media: mediaFiles.map(p => ({ url: p.url, type: p.type }))
            }),
        };
        setMessages(prev => [...prev, optimisticMessage]);

        try {
            const uploadedMedia: MediaItem[] = await Promise.all(
                mediaFiles.map(async (preview) => {
                    const filePath = `chat_media/${currentChat.id}/${Date.now()}_${preview.file.name}`;
                    const mediaRef = ref(storage, filePath);
                    await uploadBytes(mediaRef, preview.file);
                    const url = await getDownloadURL(mediaRef);
                    return { url, type: preview.type, path: filePath };
                })
            );

            const messagePayload: Omit<Message, 'id' | 'tempId' | 'status'> = {
                senderId: currentUser.id,
                createdAt: serverTimestamp() as Timestamp,
                ...(textContent && { content: textContent }),
                ...(uploadedMedia.length > 0 && { media: uploadedMedia }),
            };

            const sentMessageRef = await addDoc(collection(db, "chats", currentChat.id, "messages"), messagePayload);
            const sentMessageSnap = await getDoc(sentMessageRef);
            const sentMessage = sentMessageSnap.data();

            
            let lastMessageContent = textContent;
            if (!lastMessageContent) {
                if(uploadedMedia.length > 0) {
                    const hasVideo = uploadedMedia.some(m => m.type === 'video');
                    lastMessageContent = `${hasVideo ? '📹' : '📷'} ${uploadedMedia.length > 0 ? (uploadedMedia.length === 1 ? 'Item' : `${uploadedMedia.length} items`) : ''}`;
                }
            }
            if (!lastMessageContent) lastMessageContent = "Media sent";


            await updateDoc(doc(db, "chats", currentChat.id), {
                lastMessage: { content: lastMessageContent, senderId: currentUser.id, createdAt: sentMessage?.createdAt || serverTimestamp() },
                lastActivity: sentMessage?.createdAt || serverTimestamp(),
                [`lastRead.${currentUser.id}`]: sentMessage?.createdAt || serverTimestamp()
            });

        } catch (error) {
            console.error("Error sending message:", error);
            setMessages(prev => prev.map(m => m.tempId === tempId ? { ...m, status: 'failed' } : m));
        }
    };
    
    const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files) {
            const files = Array.from(e.target.files);
            const previews = files.map(file => ({
                url: URL.createObjectURL(file),
                file,
                type: file.type.startsWith('image/') ? 'image' : 'video' as 'image' | 'video'
            }));
            setMediaPreviews(prev => [...prev, ...previews]);
            if (fileInputRef.current) fileInputRef.current.value = "";
        }
    };
    
    const handleDeleteMessage = async (messageToDelete: Message) => {
        if (!db || !storage || !messageToDelete) return;
        setDeletingMessage(null);
        try {
            if (messageToDelete.media && messageToDelete.media.length > 0) {
                await Promise.all(messageToDelete.media.map(item => {
                    if(item.path) return deleteObject(ref(storage, item.path));
                    return Promise.resolve();
                }));
            }
            await deleteDoc(doc(db, "chats", chat.id, "messages", messageToDelete.id));
        } catch (error) {
            console.error("Error deleting message:", error);
            alert("Failed to delete message.");
        }
    };

    const getChatTitle = () => {
        const chatData = currentChat || chat;
        if (!chatData?.participants) return "Conversation";
        if (chatData.participantIds.length > 2) {
             return chatData.participantIds
                .filter(id => id !== currentUser.id)
                .map(id => chatData.participants[id]?.name.split(' ')[0] || '')
                .join(', ');
        }
        const otherId = chatData.participantIds.find(id => id !== currentUser.id);
        return otherId ? chatData.participants[otherId]?.name : "Chat";
    };
    
    return (
        <div className="conversation-page">
            <header className="conversation-header">
                <button onClick={onBack} className="back-button" aria-label="Back to chats">
                    <span className="material-symbols-outlined">arrow_back</span>
                </button>
                <h3>{getChatTitle()}</h3>
                <div style={{width: '40px'}}></div>
            </header>
            <div className="message-list">
                {loading ? <Loading message="Loading messages..." /> : (
                    <>
                        {messages.map(msg => (
                            <MessageBubble 
                                key={msg.id} 
                                message={msg} 
                                isSent={msg.senderId === currentUser.id} 
                                onMediaClick={(index) => msg.media && setViewingMedia({ media: msg.media, startIndex: index })}
                                onLongPress={() => msg.senderId === currentUser.id && setDeletingMessage(msg)}
                            />
                        ))}
                        <div ref={messagesEndRef} />
                    </>
                )}
            </div>
            <div className="message-input-container">
                {mediaPreviews.length > 0 && (
                    <div className="media-preview-container">
                        {mediaPreviews.map((p, i) => (
                            <div key={i} className="media-preview-item">
                                {p.type === 'image' ? <img src={p.url} alt="preview" /> : <video src={p.url} />}
                                <button onClick={() => setMediaPreviews(prev => prev.filter((_, idx) => idx !== i))}>
                                    <span className="material-symbols-outlined">close</span>
                                </button>
                            </div>
                        ))}
                    </div>
                )}
                <div className="message-input-row">
                    <input type="file" ref={fileInputRef} onChange={handleFileSelect} style={{display: 'none'}} multiple accept="image/*,video/*" disabled={loading} />
                    <button className="input-action-button" onClick={() => fileInputRef.current?.click()} aria-label="Attach file" disabled={loading}>
                        <span className="material-symbols-outlined">attach_file</span>
                    </button>
                    <input
                        type="text" placeholder="Type a message..." value={newMessage}
                        onChange={(e) => setNewMessage(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                        disabled={loading}
                    />
                    <button className="send-button" onClick={handleSendMessage} disabled={loading || (!newMessage.trim() && mediaPreviews.length === 0)}>
                        <span className="material-symbols-outlined">send</span>
                    </button>
                </div>
            </div>
            {deletingMessage && (
                <Modal isOpen={true} onClose={() => setDeletingMessage(null)}>
                    <div className="delete-confirmation">
                        <p>Are you sure you want to delete this message for everyone?</p>
                        <div className="form-actions">
                            <button className="action-button secondary" onClick={() => setDeletingMessage(null)}>Cancel</button>
                            <button className="action-button danger" onClick={() => handleDeleteMessage(deletingMessage)}>Delete</button>
                        </div>
                    </div>
                </Modal>
            )}
            {viewingMedia && (
                <MediaViewer
                    mediaItems={viewingMedia.media}
                    startIndex={viewingMedia.startIndex}
                    onClose={() => setViewingMedia(null)}
                />
            )}
        </div>
    );
};

const MessageBubble: React.FC<{
    message: Message;
    isSent: boolean;
    onMediaClick: (index: number) => void;
    onLongPress: () => void;
}> = ({ message, isSent, onMediaClick, onLongPress }) => {
    return (
        <div className={`message-container ${isSent ? 'sent' : 'received'}`}>
            <div 
                className={`message-bubble ${message.media ? 'has-media' : ''}`}
                onClick={onLongPress} // Simplified to onClick for web/mobile consistency
            >
                {message.media && message.media.length > 0 && (
                    <MediaGrid media={message.media} onMediaClick={onMediaClick} />
                )}
                {message.content && <p className="message-content">{message.content}</p>}
                <div className="message-footer">
                    <span className="message-timestamp">{formatTime(message.createdAt)}</span>
                    {message.status === 'uploading' && <div className="spinner-small" style={{borderColor: '#999', borderTopColor: '#666'}}></div>}
                    {message.status === 'failed' && <span className="material-symbols-outlined message-failed-indicator">error</span>}
                </div>
            </div>
        </div>
    );
};

const MediaGrid: React.FC<{ media: MediaItem[], onMediaClick: (index: number) => void }> = ({ media, onMediaClick }) => {
    const count = media.length;
    const displayMedia = count > 4 ? media.slice(0, 4) : media;

    return (
        <div className={`media-grid count-${Math.min(count, 4)}`}>
            {displayMedia.map((item, index) => (
                <div key={index} className="media-grid-item" onClick={() => onMediaClick(index)}>
                    {item.type === 'image' ? <img src={item.url} alt="media content" /> : <video src={item.url} />}
                    {item.type === 'video' && (
                        <div className="video-play-icon">
                            <span className="material-symbols-outlined">play_circle</span>
                        </div>
                    )}
                    {count > 4 && index === 3 && (
                        <div className="more-overlay">+{count - 4}</div>
                    )}
                </div>
            ))}
        </div>
    );
};

const MediaViewer: React.FC<{
    mediaItems: MediaItem[];
    startIndex: number;
    onClose: () => void;
}> = ({ mediaItems, startIndex, onClose }) => {
    const [currentIndex, setCurrentIndex] = useState(startIndex);
    const currentItem = mediaItems[currentIndex];

    const goToPrev = () => setCurrentIndex(prev => (prev === 0 ? mediaItems.length - 1 : prev - 1));
    const goToNext = () => setCurrentIndex(prev => (prev === mediaItems.length - 1 ? 0 : prev + 1));

    return createPortal(
        <div className="media-viewer-backdrop" onClick={onClose}>
            <div className="media-viewer-content" onClick={e => e.stopPropagation()}>
                {currentItem.type === 'image' 
                    ? <img src={currentItem.url} alt="media" />
                    : <video src={currentItem.url} controls autoPlay />
                }
            </div>
            <button className="media-viewer-close" onClick={onClose}><span className="material-symbols-outlined">close</span></button>
            {mediaItems.length > 1 && (
                <>
                    <button className="media-viewer-nav prev" onClick={goToPrev}><span className="material-symbols-outlined">arrow_back_ios</span></button>
                    <button className="media-viewer-nav next" onClick={goToNext}><span className="material-symbols-outlined">arrow_forward_ios</span></button>
                </>
            )}
        </div>,
        document.body
    );
};

// --- User Management (Admin) ---
const ManageUsersModal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    users: User[];
}> = ({ isOpen, onClose, users }) => {
    const { db } = useFirebase();

    const handleRoleChange = async (userId: string, role: UserRole, isChecked: boolean) => {
        if (!db) return;
        const userRef = doc(db, "users", userId);
        await updateDoc(userRef, {
            roles: isChecked ? arrayUnion(role) : arrayRemove(role)
        });
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <div className="manage-users-modal">
                <h3>Manage User Roles</h3>
                <div className="user-list user-role-list">
                    {users.map(user => (
                        <div key={user.id} className="card user-role-item">
                            <p className="user-name">{user.name}</p>
                            <p className="user-email">{user.email}</p>
                            <div className="role-checkboxes">
                                {(['admin', 'news_contributor', 'podcast_contributor'] as UserRole[]).map(role => (
                                    <label key={role}>
                                        <input
                                            type="checkbox"
                                            checked={user.roles.includes(role)}
                                            onChange={(e) => handleRoleChange(user.id, role, e.target.checked)}
                                        />
                                        {role.replace('_', ' ')}
                                    </label>
                                ))}
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        </Modal>
    );
};


// --- Notifications ---
const NotificationPanel: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    notifications: Notification[];
}> = ({ isOpen, onClose, notifications }) => {
    return createPortal(
        <>
            <div className={`notification-backdrop ${isOpen ? 'open' : ''}`} onClick={onClose}></div>
            <div className={`notification-panel ${isOpen ? 'open' : ''}`}>
                <header className="notification-header">
                    <h3>Notifications</h3>
                    <button className="panel-close-button" onClick={onClose} aria-label="Close notifications">
                        <span className="material-symbols-outlined">close</span>
                    </button>
                </header>
                <div className="notification-list">
                    {notifications.length > 0 ? (
                        notifications.map(notif => (
                            <div key={notif.id} className="notification-item">
                                <span className="material-symbols-outlined notification-icon">{notif.icon}</span>
                                <div>
                                    <p>{notif.message}</p>
                                    <p className="notification-timestamp">{notif.timestamp}</p>
                                </div>
                            </div>
                        ))
                    ) : (
                         <div className="no-notifications">
                            <p>You have no new notifications.</p>
                        </div>
                    )}
                </div>
            </div>
        </>,
        document.body
    );
};


// --- Main App Component ---
const App: React.FC = () => {
    const firebaseServices = useFirebase();
    const { auth, db } = firebaseServices;
    
    const [currentUser, setCurrentUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);
    const [activePage, setActivePage] = useState<'worship' | 'bible' | 'news' | 'podcast' | 'prayer' | 'chat' | 'conversation'>('news');
    const [isManageUsersOpen, setIsManageUsersOpen] = useState(false);
    const [isNotificationPanelOpen, setIsNotificationPanelOpen] = useState(false);
    
    // Data states
    const [worshipService, setWorshipService] = useState<WorshipService | null>(null);
    const [pastServices, setPastServices] = useState<PastWorshipService[]>([]);
    const [news, setNews] = useState<NewsItem[]>([]);
    const [podcasts, setPodcasts] = useState<Podcast[]>([]);
    const [prayerRequests, setPrayerRequests] = useState<PrayerRequest[]>([]);
    const [users, setUsers] = useState<User[]>([]);
    const [chats, setChats] = useState<Chat[]>([]);
    const [currentChat, setCurrentChat] = useState<Chat | null>(null);
    const [notifications, setNotifications] = useState<Notification[]>([]);
    const [hasUnreadNotifications, setHasUnreadNotifications] = useState(false);


    const usersMap = useMemo(() => {
        const map = new Map<string, User>();
        users.forEach(user => map.set(user.id, user));
        return map;
    }, [users]);

    // --- Authentication ---
    useEffect(() => {
        if (!auth || !db) return;
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            if (user) { 
                const userDocRef = doc(db, "users", user.uid);
                const userDocSnap = await getDoc(userDocRef);

                let rolesToAdd: UserRole[] = [];
                const existingRoles: UserRole[] = userDocSnap.exists() ? (userDocSnap.data().roles || []) : [];

                if (user.email === 'davidrai441@gmail.com' && !existingRoles.includes('admin')) {
                    rolesToAdd.push('admin');
                } else if (user.email === 'koiralacm@gmail.com') {
                    if (!existingRoles.includes('news_contributor')) rolesToAdd.push('news_contributor');
                    if (!existingRoles.includes('podcast_contributor')) rolesToAdd.push('podcast_contributor');
                }

                if (userDocSnap.exists()) {
                    if (rolesToAdd.length > 0) {
                        await updateDoc(userDocRef, { roles: arrayUnion(...rolesToAdd) });
                    }
                    
                    const userData = userDocSnap.data();
                    const finalRoles = [...new Set([...existingRoles, ...rolesToAdd])];
                    
                    if (!user.displayName && userData.name) {
                        await updateProfile(user, { displayName: userData.name });
                    }
                     if (!user.photoURL && userData.avatar) {
                        await updateProfile(user, { photoURL: userData.avatar });
                    }
                    
                    setCurrentUser({ 
                        id: user.uid, 
                        name: user.displayName || userData.name || '',
                        email: user.email || userData.email || '',
                        avatar: user.photoURL || userData.avatar || '',
                        roles: finalRoles
                    } as User);

                } else {
                    const baseRoles: UserRole[] = ['member'];
                    const finalRoles = [...new Set([...baseRoles, ...rolesToAdd])];
                    
                    const newUser: Omit<User, 'id'> = {
                        name: user.displayName || 'New User',
                        email: user.email || '',
                        avatar: user.photoURL || '',
                        roles: finalRoles,
                    };
                    await setDoc(userDocRef, newUser);
                    setCurrentUser({ id: user.uid, ...newUser } as User);
                }
            } else {
                setCurrentUser(null);
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, [auth, db]);


    // --- Data Fetching (Hardened against missing indexes) ---
    useEffect(() => {
        if (!db || !currentUser) return;
        
        // Listeners
        const unsubWorship = onSnapshot(query(collection(db, "worshipServices"), where("isLive", "==", true), limit(1)), (snapshot) => {
            setWorshipService(snapshot.empty ? null : { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as WorshipService);
        });

        const unsubPastWorship = onSnapshot(query(collection(db, "pastWorshipServices")), (snapshot) => {
            const services = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as PastWorshipService));
            services.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
            setPastServices(services);
        });

        const unsubNews = onSnapshot(query(collection(db, "news")), (snapshot) => {
            const items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as NewsItem));
            items.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
            setNews(items);
        });

        const unsubPodcasts = onSnapshot(query(collection(db, "podcasts")), (snapshot) => {
            const podcasts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Podcast));
            podcasts.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
            setPodcasts(podcasts);
        });

        const unsubPrayer = onSnapshot(query(collection(db, "prayerRequests")), (snapshot) => {
            const requests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as PrayerRequest));
            requests.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
            setPrayerRequests(requests);
        });

        const unsubUsers = onSnapshot(query(collection(db, "users")), (snapshot) => {
            const users = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as User));
            users.sort((a, b) => a.name.localeCompare(b.name));
            setUsers(users);
        });

        const unsubChats = onSnapshot(
            query(collection(db, "chats"), where("participantIds", "array-contains", currentUser.id)),
            (snapshot) => {
                const fetchedChats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Chat));
                fetchedChats.sort((a, b) => (b.lastActivity?.toMillis() || 0) - (a.lastActivity?.toMillis() || 0));
                setChats(fetchedChats);
            }
        );

        return () => {
            unsubWorship();
            unsubPastWorship();
            unsubNews();
            unsubPodcasts();
            unsubPrayer();
            unsubUsers();
            unsubChats();
        };

    }, [db, currentUser]);
    
    // --- FCM/Push Notifications ---
    useEffect(() => {
        if (!firebaseServices.messaging || !currentUser || !db) return;
        const { messaging } = firebaseServices;

        const requestPermissionAndToken = async () => {
            try {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    const currentToken = await getToken(messaging, { vapidKey: import.meta.env.VITE_FIREBASE_VAPID_KEY });
                    if (currentToken) {
                        const userTokens = currentUser.fcmTokens || [];
                        if (!userTokens.includes(currentToken)) {
                            await updateDoc(doc(db, "users", currentUser.id), {
                                fcmTokens: arrayUnion(currentToken)
                            });
                        }
                    } else {
                        console.log('No registration token available. Request permission to generate one.');
                    }
                }
            } catch (err) {
                console.error('An error occurred while retrieving token. ', err);
            }
        };
        
        requestPermissionAndToken();

        const unsubscribeOnMessage = onMessage(messaging, (payload) => {
             console.log('Message received in foreground. ', payload);
             const notificationData = payload.notification || {};
             const dataPayload = payload.data || {};

             const messageBody = dataPayload.body || notificationData.body || '새로운 알림이 있습니다.';
             const messageIcon = dataPayload.icon || notificationData.icon || 'notifications';

             const newNotification: Notification = {
                id: payload.messageId || new Date().toISOString(),
                icon: messageIcon,
                message: messageBody,
                timestamp: new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })
             };
             setNotifications(prev => [newNotification, ...prev]);
             setHasUnreadNotifications(true);
        });

        return () => unsubscribeOnMessage();
    }, [firebaseServices.messaging, currentUser, db]);


    const handleCreateChat = async (selectedUsers: User[]): Promise<string | null> => {
        if (!db || !currentUser) return null;
        
        const allParticipants = [currentUser, ...selectedUsers];
        const allParticipantIds = allParticipants.map(p => p.id).sort();

        // Check if a chat with these exact participants already exists to avoid duplicates (works for 1-on-1 and groups).
        const q = query(collection(db, "chats"), where("participantIds", "==", allParticipantIds));
        const existingChats = await getDocs(q);
        if (!existingChats.empty) {
           return existingChats.docs[0].id; // Return existing chat ID
        }
       
        const participantsData = allParticipants.reduce((acc, user) => {
            acc[user.id] = { name: user.name, avatar: user.avatar };
            return acc;
        }, {} as { [key: string]: { name: string, avatar: string }});

        try {
             const newChatRef = await addDoc(collection(db, "chats"), {
                participantIds: allParticipantIds,
                participants: participantsData,
                lastActivity: serverTimestamp(),
            });
            return newChatRef.id;
        } catch (error) {
            console.error("Error creating chat:", error);
            return null;
        }
    };

    const handleBackFromConversation = useCallback(() => {
        setActivePage('chat');
    }, []);


    if (firebaseServices.firebaseError) {
        return <ErrorFallback error={new Error(firebaseServices.firebaseError)} />;
    }
    if (loading) {
        return <SplashScreen />;
    }
    if (!currentUser) {
        return <LoginPage />;
    }
    
    const pageConfig = {
        news: { label: 'सुचना', icon: 'feed' },
        worship: { label: 'आरधना', icon: 'church' },
        podcast: { label: 'Podcast', icon: 'podcasts' },
        bible: { label: 'बाइबल', icon: 'menu_book' },
        chat: { label: 'संगतिहरु', icon: 'groups' },
        prayer: { label: 'प्रार्थना', icon: 'volunteer_activism' },
    };
    
    const navOrder: (keyof typeof pageConfig)[] = ['news', 'worship', 'podcast', 'bible', 'chat', 'prayer'];


    const renderPage = () => {
        switch(activePage) {
            case 'news': return <NewsPage currentUser={currentUser} news={news} setNews={setNews} />;
            case 'worship': return <WorshipPage currentUser={currentUser} liveService={worshipService} pastServices={pastServices} />;
            case 'podcast': return <PodcastsPage currentUser={currentUser} podcasts={podcasts} setPodcasts={setPodcasts} />;
            case 'bible': return <BiblePage />;
            case 'chat': return (
                <ChatListPage
                    currentUser={currentUser}
                    usersMap={usersMap}
                    chats={chats}
                    onChatSelect={(chat) => {
                        setCurrentChat(chat);
                        setActivePage('conversation');
                    }}
                    onCreateChat={handleCreateChat}
                />
            );
            case 'prayer': return <PrayerPage currentUser={currentUser} requests={prayerRequests} setRequests={setPrayerRequests} />;
            case 'conversation': 
                if(!currentChat) {
                    setActivePage('chat'); // safety net
                    return null;
                }
                return (
                    <ConversationPage 
                        chat={currentChat} 
                        currentUser={currentUser} 
                        onBack={handleBackFromConversation} 
                    />
                );
            default: return <div>Page not found</div>;
        }
    };

    const isAdmin = currentUser.roles.includes('admin');

    return (
        <div className="app-container">
            {activePage !== 'conversation' && (
                <header className="app-header">
                    <div className="header-content">
                        <img src={CHURCH.logo} alt="Church Logo" className="header-logo" />
                        <h1>{CHURCH.name}</h1>
                    </div>
                    <div className="header-actions">
                        <button className="header-button" onClick={() => {
                            setIsNotificationPanelOpen(true);
                            setHasUnreadNotifications(false);
                        }}>
                            <span className="material-symbols-outlined">notifications</span>
                            {hasUnreadNotifications && <div className="notification-dot"></div>}
                        </button>
                         {isAdmin && (
                            <button className="header-button" onClick={() => setIsManageUsersOpen(true)}>
                                <span className="material-symbols-outlined">manage_accounts</span>
                            </button>
                         )}
                        <button className="header-button" onClick={() => auth && signOut(auth)}>
                            <span className="material-symbols-outlined">logout</span>
                        </button>
                    </div>
                </header>
            )}

            <main className={`main-content ${activePage === 'conversation' ? 'full-height' : ''}`}>
                {renderPage()}
            </main>

            {activePage !== 'conversation' && (
                <nav className="bottom-nav">
                    {navOrder.map(page => (
                        <button key={page} className={`nav-item ${activePage === page ? 'active' : ''}`} onClick={() => setActivePage(page)}>
                            <span className="material-symbols-outlined">
                                {pageConfig[page].icon}
                            </span>
                            <span>{pageConfig[page].label}</span>
                        </button>
                    ))}
                </nav>
            )}
            
            <ManageUsersModal
                isOpen={isManageUsersOpen}
                onClose={() => setIsManageUsersOpen(false)}
                users={users}
            />
            
            <NotificationPanel 
                isOpen={isNotificationPanelOpen}
                onClose={() => setIsNotificationPanelOpen(false)}
                notifications={notifications}
            />
        </div>
    );
};


// --- Error Boundary ---
interface ErrorBoundaryProps {
  children: React.ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  public state: ErrorBoundaryState = { hasError: false, error: null };

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error: error };
  }

  public componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  public render() {
    const { hasError, error } = this.state;
    const { children } = this.props;
    if (hasError && error) {
      return <ErrorFallback error={error} />;
    }
    return children;
  }
}



// --- App Root ---
const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(
    <React.StrictMode>
        <ErrorBoundary>
            <FirebaseContext.Provider value={initializeFirebaseServices()}>
                <App />
            </FirebaseContext.Provider>
        </ErrorBoundary>
    </React.StrictMode>
);

// --- Service Worker Registration ---
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js').then(registration => {
      console.log('SW registered: ', registration);
    }).catch(registrationError => {
      console.log('SW registration failed: ', registrationError);
    });
  });
}